"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1634],{28453(e,n,t){t.d(n,{R:()=>s,x:()=>d});var r=t(96540);const i={},o=r.createContext(i);function s(e){const n=r.useContext(o);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(o.Provider,{value:n},e.children)}},73810(e,n,t){t.r(n),t.d(n,{assets:()=>a,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"extensions/raw-strings","title":"Raw Strings","description":"Custom raw-string extensions allows adding new functions that operate on raw strings and registering them with Garnet. This registered function can then be invoked from any Garnet client and be executed on the Garnet server.","source":"@site/docs/extensions/raw-strings.md","sourceDirName":"extensions","slug":"/extensions/raw-strings","permalink":"/garnet/docs/extensions/raw-strings","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/garnet/tree/main/website/docs/extensions/raw-strings.md","tags":[],"version":"current","frontMatter":{"id":"raw-strings","sidebar_label":"Raw Strings","title":"Raw Strings"},"sidebar":"garnetDocSidebar","previous":{"title":"Overview","permalink":"/garnet/docs/extensions/overview"},"next":{"title":"Objects","permalink":"/garnet/docs/extensions/objects"}}');var i=t(74848),o=t(28453);const s={id:"raw-strings",sidebar_label:"Raw Strings",title:"Raw Strings"},d="Server-Side Raw-String Extensions",a={},c=[{value:"Developing custom server side Raw-String Extensions",id:"developing-custom-server-side-raw-string-extensions",level:3}];function l(e){const n={a:"a",br:"br",code:"code",em:"em",h1:"h1",h3:"h3",header:"header",li:"li",p:"p",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"server-side-raw-string-extensions",children:"Server-Side Raw-String Extensions"})}),"\n",(0,i.jsx)(n.p,{children:"Custom raw-string extensions allows adding new functions that operate on raw strings and registering them with Garnet. This registered function can then be invoked from any Garnet client and be executed on the Garnet server."}),"\n",(0,i.jsx)(n.h3,{id:"developing-custom-server-side-raw-string-extensions",children:"Developing custom server side Raw-String Extensions"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.code,{children:"CustomRawStringFunctions"})," is the base class for all custom raw-string functions. To develop a new one, this class has to be extended and then include the custom logic. There are six methods to be implemented in a new custom raw-string function:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GetInitialLength(ref RawStringInput input)"}),":",(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"GetInitialLength"})," method returns the length of the initial expected length of value when populated by RMW using given input"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GetLength(ReadOnlySpan<byte> value, ref RawStringInput input)"}),(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"GetLength"})," method returns the length of resulting value object when performing RMW modification of value using given input"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InitialUpdater(ReadOnlySpan<byte> key, ref RawStringInput input, Span<byte> value, ref RespMemoryWriter writer, ref RMWInfo rmwInfo)"}),(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"InitialUpdater"})," method makes an initial update for RMW, given the key (",(0,i.jsx)(n.code,{children:"key"}),"), the given input (",(0,i.jsx)(n.code,{children:"input"}),"), the resulting value to be inserted (",(0,i.jsx)(n.code,{children:"value"}),"), the writer to output the result of the ",(0,i.jsx)(n.code,{children:"input"})," operation on ",(0,i.jsx)(n.code,{children:"value"})," (",(0,i.jsx)(n.code,{children:"writer"}),") and the reference for the record info for this record (used for locking) (",(0,i.jsx)(n.code,{children:"rmwInfo"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"InPlaceUpdater(ReadOnlySpan<byte> key, ref RawStringInput input, Span<byte> value, ref int valueLength, ref RespMemoryWriter writer, ref RMWInfo rmwInfo)"}),(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"InPlaceUpdater"})," method performs an in-place update for RMW, given the key (",(0,i.jsx)(n.code,{children:"key"}),"), the given input for computing the updated (",(0,i.jsx)(n.code,{children:"input"}),"), the destination to be updated (",(0,i.jsx)(n.code,{children:"value"}),"), the writer to output the result of the ",(0,i.jsx)(n.code,{children:"input"})," operation on ",(0,i.jsx)(n.code,{children:"value"})," (",(0,i.jsx)(n.code,{children:"writer"}),") and the location where"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"CopyUpdater(ReadOnlySpan<byte> key, ref RawStringInput input, ReadOnlySpan<byte> oldValue, Span<byte> newValue, ref RespMemoryWriter writer, ref RMWInfo rmwInfo)"}),(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"CopyUpdate"})," method performs a copy update for RMW, given the key (",(0,i.jsx)(n.code,{children:"key"}),"), the given input for computing ",(0,i.jsx)(n.code,{children:"newValue"})," from ",(0,i.jsx)(n.code,{children:"oldValue"})," (",(0,i.jsx)(n.code,{children:"input"}),"), the previous value to be copied/updated (",(0,i.jsx)(n.code,{children:"oldValue"}),"), the destination to be updated (",(0,i.jsx)(n.code,{children:"newValue"}),"), the writer copying ",(0,i.jsx)(n.code,{children:"newValue"})," (",(0,i.jsx)(n.code,{children:"writer"}),") and the reference for the record info for this record (used for locking) (",(0,i.jsx)(n.code,{children:"rmwInfo"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"Reader(ReadOnlySpan<byte> key, ref RawStringInput input, ReadOnlySpan<byte> value, ref RespMemoryWriter writer, ref ReadInfo readInfo);"}),(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"Reader"})," method performs a record read, given the key for the record to be read (",(0,i.jsx)(n.code,{children:"key"}),"), the user input for computing ",(0,i.jsx)(n.code,{children:"writer"})," from ",(0,i.jsx)(n.code,{children:"value"})," (",(0,i.jsx)(n.code,{children:"input"}),"), the value for the record being read (",(0,i.jsx)(n.code,{children:"value"}),"), the writer to output ",(0,i.jsx)(n.code,{children:"value"})," (",(0,i.jsx)(n.code,{children:"writer"}),") and the reference for the record info for this record (used for locking) (",(0,i.jsx)(n.code,{children:"rmwInfo"}),")"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"There are two other optional methods to be implemented:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"NeedInitialUpdate(ReadOnlySpan<byte> key, ref RawStringInput input, ref RespMemoryWriter writer)"}),(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"NeedInitialUpdate"})," determines whether copy-update for RMW should be invoked, given the key for the record (",(0,i.jsx)(n.code,{children:"key"}),"), the user input to be used for computing the updated value (",(0,i.jsx)(n.code,{children:"value"}),") and the location where the result of the ",(0,i.jsx)(n.code,{children:"input"})," operation is to be copied.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Note:"})})," If this method is not overridden, it returns ",(0,i.jsx)(n.code,{children:"true"})," by default"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"NeedCopyUpdate(ReadOnlySpan<byte> key, ref RawStringInput input, ReadOnlySpan<byte> oldValue, ref RespMemoryWriter writer)"}),(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"NeedCopyUpdate"})," determines whether copy-update for RMW should be invoked, given the key for the record (",(0,i.jsx)(n.code,{children:"key"}),"), the user input to be used for computing the updated value (",(0,i.jsx)(n.code,{children:"value"}),"), the existing value that would be copied (",(0,i.jsx)(n.code,{children:"oldValue"}),") and the location where the result of the ",(0,i.jsx)(n.code,{children:"input"})," operation on ",(0,i.jsx)(n.code,{children:"oldValue"})," is to be copied.",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.em,{children:(0,i.jsx)(n.strong,{children:"Note:"})})," If this method is not overridden, it returns ",(0,i.jsx)(n.code,{children:"true"})," by default"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These are the helper methods for developing custom transactions."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GetNextArg(ref RawStringInput input, scoped ref int offset)"}),":",(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"GetNextArg"})," method is used to retrieve the next argument from the input at the specified offset. It takes an ArgSlice parameter representing the input and a reference to an int offset. It returns an ArgSlice object representing the argument as a span. The method internally reads a pointer with a length header to extract the argument."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"GetFirstArg(ref RawStringInput input)"}),":",(0,i.jsx)(n.br,{}),"\n","The ",(0,i.jsx)(n.code,{children:"GetFirseArg"})," method is used to retrieve the argument from the input at offset 0."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Registering the custom raw-string function is done on the server-side by calling the ",(0,i.jsx)(n.code,{children:"NewCommand(string name, int numParams, CommandType type, CustomRawStringFunctions customFunctions, long expirationTicks = 0)"})," method on the Garnet server object's ",(0,i.jsx)(n.code,{children:"RegisterAPI"})," object with its name, number of parameters, the CommandType (Read / ReadModifyWrite), an instance of the custom raw-string function class, and optionally the number of ticks for expiration.",(0,i.jsx)(n.br,{}),"\n","It is possible to register the custom raw-string function from the client-side as well (as an admin command, given that the code already resides on the server) by using the ",(0,i.jsx)(n.code,{children:"REGISTERCS"})," command (see ",(0,i.jsx)(n.a,{href:"/garnet/docs/dev/custom-commands",children:"Custom Commands"}),")."]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);