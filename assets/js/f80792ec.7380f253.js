"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9079],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>r});var o=n(96540);const a={},i=o.createContext(a);function s(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),o.createElement(i.Provider,{value:t},e.children)}},36569:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"dev/tsavorite/epoch","title":"Epoch Protection Framework","description":"Context","source":"@site/docs/dev/tsavorite/epochprotection.md","sourceDirName":"dev/tsavorite","slug":"/dev/tsavorite/epoch","permalink":"/garnet/docs/dev/tsavorite/epoch","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/garnet/tree/main/website/docs/dev/tsavorite/epochprotection.md","tags":[],"version":"current","frontMatter":{"id":"epoch","sidebar_label":"EpochProtection","title":"Epoch Protection Framework"},"sidebar":"garnetDocSidebar","previous":{"title":"StoreFunctions","permalink":"/garnet/docs/dev/tsavorite/storefunctions"},"next":{"title":"Transactions","permalink":"/garnet/docs/dev/transactions"}}');var a=n(74848),i=n(28453);const s={id:"epoch",sidebar_label:"EpochProtection",title:"Epoch Protection Framework"},r="Light Epoch Protection in Garnet (Latch-free lazy synchronization)",h={},c=[{value:"Context",id:"context",level:2},{value:"Epoch Protection (10,000-foot view)",id:"epoch-protection-10000-foot-view",level:2},{value:"Implementation Details",id:"implementation-details",level:2},{value:"Relevant Public Methods and How to use them",id:"relevant-public-methods-and-how-to-use-them",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"light-epoch-protection-in-garnet-latch-free-lazy-synchronization",children:"Light Epoch Protection in Garnet (Latch-free lazy synchronization)"})}),"\n",(0,a.jsx)(t.h2,{id:"context",children:"Context"}),"\n",(0,a.jsxs)(t.p,{children:["We need to ensure shared variables are not being read and mutated simultaneously without determinisitic orderings. Commonly used concurreny primitives such as Mutexes and sempahores provided by the language require threads to synchronize frequently with each other. This Synchronization across threads is expensive; Epoch protection ",(0,a.jsx)(t.strong,{children:"reduces the frequency of synchronization across threads"}),"."]}),"\n",(0,a.jsx)(t.h2,{id:"epoch-protection-10000-foot-view",children:"Epoch Protection (10,000-foot view)"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:'LightEpoch provides a synchronization mechanism where the write path does not need to block the thread but can be enqueued as a callback action task. The write path is handed off to the instance of LightEpoch to ensure the write does not run when another thread may have the epoch "acquired" or the state being read at a given version.'}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"As a user, you can use Epoch protection to confidently see the latest state of shared variables without worrying about changes to their state. The overall epoch system proceeds with updating the state only when the thread is done viewing the version of the state."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:'LightEpoch is used because it can run certain operations after other threads that have seen the previous state are no longer executing (that is the basis of epoch control). It\'s not really "mutual exclusion". It\'s more like setting address boundaries and operating in them in such a way that there is no conflict. Really briefly: threads "protect" the current epoch by saying "I am active in this epoch" (where "epoch" is a counter). When they are done, they remove that protection. When some operation that would change shared variables (like \'HeadAddress\') is going to run, it is done by "bumping" the epoch, which increases the counter then waits until no other thread is operating with the previous value protected. Variables are set before the bump so that any thread seeing the new counter value also sees the updated variables (again, e.g., \'HeadAddress\') so we know that we are safe to operate up to the current \'HeadAddress\', which is past the previous one.'}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["There is a system-wide LightEpoch threads array with N entries, where ",(0,a.jsx)(t.code,{children:"N = max(128, ProcessorCount * 2)"}),". This means a given LightEpoch can support up to 128 threads. In the code, you may notice that while we allocate and set the table to the variable tableRaw, all interactions with the Epoch Table are via tableAligned. This optimization is for cache line sizes on modern processors and L1-L3 caches (64-byte cache line size). When a thread becomes part of the Epoch Protection system, we add it to the epoch table and store a thread-local epoch for that thread in the Epoch Table. At the start of being added to the Epoch Table, the thread-local epoch is set to the current global epoch."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:'Each time we "acquire" an epoch, a thread will claim ownership over an epoch counter. Any new incoming threads will take over the epochs only after this one.'}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsx)(t.p,{children:"Each thread that has access to the LightEpoch object can bump the global Epoch (global to the scope of the instance of the LightEpoch class, shared across threads)."}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["We can add trigger actions that are executed when all threads are past a safe epoch ",(0,a.jsx)(t.code,{children:"(For every thread T: SafeEpoch <= thread local Epoch <= Global Epoch)"}),". Since the system holds all thread local epochs in a system accesible epoch table we can scan and find a safe epoch.\nThis gives us the ability to have an exactly-once invoked function that depends on all threads logically coordinating and not having any code being executed at the time of Epoch ending for the trigger."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:["If you look closely, what ",(0,a.jsx)(t.code,{children:"epoch.Resume()"}),' essentially does is have a thread find a free entry in the epoch table, put its id there, and "claim" the current epoch (the next thread will increment the epoch by 1 and claim the next epoch). Inside ',(0,a.jsx)(t.code,{children:"epoch.Resume()"}),", there is a loop; if the current target epoch entry is already occupied by another thread, the current thread will yield. When it wakes up, it will try to occupy the next entry. If the epoch table is full, the rest of the threads will keep yielding."]}),"\n"]}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"relevant-public-methods-and-how-to-use-them",children:"Relevant Public Methods and How to use them"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"ThisInstanceProtected"}),": Tells us whether the calling thread owns an entry in the epoch table, i.e., is participating in Epoch Protection at the moment. If not, you can have it participate in epoch protection by calling ",(0,a.jsx)(t.code,{children:"Resume"}),"."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"ProtectAndDrain"}),": Marks the current thread as the owner of an updated epoch and performs draining of actions up to that point. This is used by Resume internally. It acts as a way to refresh the shared variables by draining pending actions. Often used inside loops to ensure we are progressively draining actions."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"Suspend"}),": Use this to let go of the ownership of an epoch. If the thread calling Suspend is the last active thread in the LightEpoch system, the pending actions/writes are invoked."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"Resume"}),": Use this when a thread needs to view a refreshed state of the shared variables to the latest state that is considered safe by all other threads. It acts as a temporal boundary to apply pending actions/writes before using the shared variables."]}),"\n"]}),"\n",(0,a.jsxs)(t.li,{children:["\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"BumpCurrentEpoch(Action)"}),": Use this to schedule a write or an action for later at a temporal boundary where it is safe to change the state of a shared variable. A call to this may drain actions if, during iterations, it finds values it can drain."]}),"\n"]}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);