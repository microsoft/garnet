"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[1590],{28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(96540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}},42851:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"cluster/overview","title":"Overview","description":"Garnet cluster provides an easy and scalable way to operate Garnet across multiple nodes.","source":"@site/docs/cluster/overview.md","sourceDirName":"cluster","slug":"/cluster/overview","permalink":"/garnet/docs/cluster/overview","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/garnet/tree/main/website/docs/cluster/overview.md","tags":[],"version":"current","frontMatter":{"id":"overview","sidebar_label":"Overview","title":"Overview","slug":"overview"},"sidebar":"garnetDocSidebar","previous":{"title":"Modules","permalink":"/garnet/docs/extensions/module"},"next":{"title":"Replication","permalink":"/garnet/docs/cluster/replication"}}');var r=t(74848),i=t(28453);const o={id:"overview",sidebar_label:"Overview",title:"Overview",slug:"overview"},a="Garnet Cluster Overview",c={},l=[{value:"Garnet Cluster Sharding",id:"garnet-cluster-sharding",level:2},{value:"Client Redirection",id:"client-redirection",level:3},{value:"Garnet Cluster Configuration",id:"garnet-cluster-configuration",level:2},{value:"Control Plane",id:"control-plane",level:2},{value:"Creating a Garnet Cluster",id:"creating-a-garnet-cluster",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"garnet-cluster-overview",children:"Garnet Cluster Overview"})}),"\n",(0,r.jsxs)(n.p,{children:["Garnet cluster provides an easy and scalable way to operate Garnet across multiple nodes.\nIt supports multiple features including ",(0,r.jsx)(n.strong,{children:"scaling up/down"}),", ",(0,r.jsx)(n.strong,{children:"data migration"}),", and ",(0,r.jsx)(n.strong,{children:"data replication"}),".\nThis document presents an overview of the sharding mechanics and cluster configuration."]}),"\n",(0,r.jsx)(n.h2,{id:"garnet-cluster-sharding",children:"Garnet Cluster Sharding"}),"\n",(0,r.jsx)(n.p,{children:"The cluster's key space is split into 16384 slots.\nAny given slot is owned by a single primary Garnet instance, and any given key maps to only a single slot.\nIf chosen to setup Garnet with replication, a Garnet instance can operate as a replica and serve read-only requests\nfor the keys hashing to slots owned by their corresponding primaries.\nAll single key operations are supported in Garnet cluster.\nHowever, multikey operations are processed only if all keys involved are mapped to a single slot.\nUsers can overcome this restriction by using hashtags to map differents keys to the same slot.\nIf a key contains {...}, only the string enclosed is used for the hash function computation.\nFor example, keys {abc}xyz and xyz{abc} will hash in the same hashlot."}),"\n",(0,r.jsx)(n.h3,{id:"client-redirection",children:"Client Redirection"}),"\n",(0,r.jsx)(n.p,{children:"Clients can connect to any node in the cluster and issues single/multi-key operations or any type of\ncluster management operations.\nThe receiving node processes single/multi-key operations by calculating the hashlot value(s) for the key(s) associated with the corresponding operation\nand responds in one of the following ways:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If the slot is owned by the receiving node, it performs the actual operation as expected from standalone Garnet."}),"\n",(0,r.jsx)(n.li,{children:"If the slot is owned by the another node, it responds with -MOVED <slot> <address> <port>"}),"\n",(0,r.jsx)(n.li,{children:"If the receiving node is a replica, it will serve only read requests to the slots owned by its primary and redirect any write requests to the primary using -MOVED message."}),"\n",(0,r.jsxs)(n.li,{children:["If the slot is owned by the receiving node and that slot is migrating then:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"If the key exists, then read requests are served as normal while write requests return -MIGRATING."}),"\n",(0,r.jsx)(n.li,{children:"If the key does not exist, then read and write requests return -ASK <slot> <address> <port>."}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["If the slot is owned by the another node and the receiving node is the target of the migration operation then:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Read and write requests are served only if ASKING issued before hand. Note that write safety is not ensured if ASKING is used, so clients should take extra care when using it."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"garnet-cluster-configuration",children:"Garnet Cluster Configuration"}),"\n",(0,r.jsx)(n.p,{children:"Every Garnet cluster instance retains a persistent local copy of the cluster configuration.\nConfiguration updates are either directly applied through cluster commands to a specific node\nor propagated through the gossip protocol."}),"\n",(0,r.jsx)(n.p,{children:"The cluster configuration contain slot assignment information and information about every known node\nin the cluster."}),"\n",(0,r.jsxs)(n.p,{children:["For more information about the cluster configuration please see the description of ",(0,r.jsx)(n.em,{children:"CLUSTER NODES"})," command."]}),"\n",(0,r.jsx)(n.h2,{id:"control-plane",children:"Control Plane"}),"\n",(0,r.jsxs)(n.p,{children:["It is important to keep in mind that Garnet's cluster mode design is currently ",(0,r.jsx)(n.em,{children:"passive"}),": this means that it does not implement leader election, and simply responds to cluster\ncommands issued by a separate ",(0,r.jsx)(n.em,{children:"control plane"}),". Users have to deploy a control plane (such as an operator in Kubernetes\n[",(0,r.jsx)(n.a,{href:"https://github.com/OT-CONTAINER-KIT/redis-operator",children:"example"}),"]) to detect failures and request failover. Garnet does not itself yet provide a control plane implementation.\nAll commands necessary for building a robust control plane are included in Garnet, and our partners have built and deployed\nproduction-quality control plane implementations for internal use with Garnet."]}),"\n",(0,r.jsxs)(n.p,{children:["This separation of concerns allows users the flexibility of deploying Garnet over a variety of fabrics such as ",(0,r.jsx)(n.a,{href:"https://kubernetes.io/",children:"Kubernetes"}),",\n",(0,r.jsx)(n.a,{href:"https://learn.microsoft.com/en-us/azure/virtual-machine-scale-sets/overview",children:"Virtual Machine Scale Sets"}),", and ",(0,r.jsx)(n.a,{href:"https://azure.microsoft.com/en-us/products/service-fabric",children:"Service Fabric"}),".\nThis allows users to leverage the production-grade leader election features available in these systems, as well as components such as reliable cloud databases for metadata storage,\nfor managing the Garnet cluster."]}),"\n",(0,r.jsx)(n.h2,{id:"creating-a-garnet-cluster",children:"Creating a Garnet Cluster"}),"\n",(0,r.jsx)(n.p,{children:"Before showing how to create a Garnet cluster, we present below a brief overview of the most important parameters associated\nwith running a basic Garnet cluster deployment."}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"--port"}),": Port to run server on. Same port is used for serving queries and internode communication."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"--bind"}),": IP address to bind server"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"--checkpointdir"}),": Used to specify the path to checkpoint location and cluster config when --cluster option is enabled."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"--cluster"}),": Enable cluster mode"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"--cluster-timeout"}),": Internode communication timeout."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"--gossip-delay"}),": Gossip protocol delay to broadcast send updated configuration or ping known nodes."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"--gossip-sp"}),": Percent of cluster nodes to gossip with at each gossip iteration"]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["To create a Garnet cluster you need first to run Garnet instances using the ",(0,r.jsx)(n.code,{children:"--cluster"})," option as shown below.\nUsing the ",(0,r.jsx)(n.code,{children:"--checkpointdir"})," option is optional. It is include in this example to avoid any conflicts between the configuration\nfiles.\nIf you don't specify the ",(0,r.jsx)(n.code,{children:"--checkpointdir"})," option Garnet will you the startup folder to save any configuration associated"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"\tGarnetServer --cluster --checkpointdir clusterData/7000 --port 7000\n\tGarnetServer --cluster --checkpointdir clusterData/7001 --port 7001\n\tGarnetServer --cluster --checkpointdir clusterData/7002 --port 7002\n"})}),"\n",(0,r.jsx)(n.p,{children:"Once the instance are up and running, you can use any kind of redis compatible client to initialize\nthe cluster to assign slots."}),"\n",(0,r.jsx)(n.p,{children:"For the above example, we use redis-cli to demonstrate how a cluster is initialized"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"\tredis-cli --cluster create 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 --cluster-yes\n"})}),"\n",(0,r.jsx)(n.p,{children:"Once the above initialization completes, the cluster is ready to process client queries.\nAn example of how one may use the initialized cluster is shown below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'PS C:\\Dev> redis-cli -p 7000\n127.0.0.1:7000> cluster nodes\nee337ebd15255c163b0d6faa4d055cdb26215938 127.0.0.1:7000@17000,hostname01 myself,master - 0 0 1 connected 0-5460\n4f86082c3d3250c0dba0f925e71963d46974fbca 127.0.0.1:7002@17002,hostname02 master - 0 0 3 connected 10923-16383\ncf333332b44a32fa70c30862b6d9535e9bac19f9 127.0.0.1:7001@17001,hostname03 master - 0 0 2 connected 5461-10922\n127.0.0.1:7000> cluster keyslot x\n(integer) 16287\n127.0.0.1:7000> get x\n(error) MOVED 16287 10.159.2.73:7002\n127.0.0.1:7000> set x 1234\n(error) MOVED 16287 10.159.2.73:7002\n127.0.0.1:7000> cluster keyslot wxz\n(integer) 949\n127.0.0.1:7000> set wxz 1234\nOK\n127.0.0.1:7000> get wxz\n"1234"\n127.0.0.1:7000>\n'})}),"\n",(0,r.jsx)(n.p,{children:"Alternatively, it is possible to configure the cluster manually or programmatically using a combination of the CLUSTER MEET, CLUSTER SET-CONFIG-EPOCH, CLUSTER ADDSLOTS or CLUSTER ADDSLOTSRANGE, and CLUSTER REPLICATE commands.\nThe following example demonstrates how to initialize two nodes, assign all slots to one of them, introduce the nodes to each other, and configure the second node as a replica of the first."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"PS C:\\Dev> redis-cli -p 7000 cluster nodes\nd6c7f0c2a2839efad9a6578647d6456f90845836 127.0.0.1:7000@17000,localhost myself,master - 0 0 0 connected\nPS C:\\Dev> redis-cli -p 7001 cluster nodes\nc65d29d420960fe5213ccb87ce1f74d7ee6ca4f1 127.0.0.1:7001@17001,localhost myself,master - 0 0 0 connected\nPS C:\\Dev> redis-cli -p 7000 cluster set-config-epoch 1\nOK\nPS C:\\Dev> redis-cli -p 7001 cluster set-config-epoch 2\nOK\nPS C:\\Dev> redis-cli -p 7000 cluster addslotsrange 0 16383\nOK\nPS C:\\Dev> redis-cli -p 7000 cluster nodes\nd6c7f0c2a2839efad9a6578647d6456f90845836 127.0.0.1:7000@17000,localhost myself,master - 0 0 1 connected 0-16383\nPS C:\\Dev> redis-cli -p 7001 cluster nodes\nc65d29d420960fe5213ccb87ce1f74d7ee6ca4f1 127.0.0.1:7001@17001,localhost myself,master - 0 0 2 connected\nPS C:\\Dev> redis-cli -p 7000 cluster meet 127.0.0.1 7001\nOK\nPS C:\\Dev> redis-cli -p 7000 cluster nodes\nd6c7f0c2a2839efad9a6578647d6456f90845836 127.0.0.1:7000@17000,localhost myself,master - 0 0 1 connected 0-16383\nc65d29d420960fe5213ccb87ce1f74d7ee6ca4f1 127.0.0.1:7001@17001,localhost master - 638875895159094739 0 2 connected\nPS C:\\Dev> redis-cli -p 7001 cluster nodes\nc65d29d420960fe5213ccb87ce1f74d7ee6ca4f1 127.0.0.1:7001@17001,localhost myself,master - 0 0 2 connected\nd6c7f0c2a2839efad9a6578647d6456f90845836 127.0.0.1:7000@17000,localhost master - 638875895161944429 0 1 connected 0-16383\nPS C:\\Dev> redis-cli -p 7001 cluster replicate $(redis-cli -p 7000 cluster myid)\nOK\nPS C:\\Dev> redis-cli -p 7000 cluster nodes\nd6c7f0c2a2839efad9a6578647d6456f90845836 127.0.0.1:7000@17000,localhost myself,master - 0 0 1 connected 0-16383\nc65d29d420960fe5213ccb87ce1f74d7ee6ca4f1 127.0.0.1:7001@17001,localhost slave d6c7f0c2a2839efad9a6578647d6456f90845836 638875895309129088 638875895309125478 3 connected\nPS C:\\Dev> redis-cli -p 7001 cluster nodes\nc65d29d420960fe5213ccb87ce1f74d7ee6ca4f1 127.0.0.1:7001@17001,localhost myself,slave d6c7f0c2a2839efad9a6578647d6456f90845836 0 0 3 connected\nd6c7f0c2a2839efad9a6578647d6456f90845836 127.0.0.1:7000@17000,localhost master - 638875895311833070 638875895311830232 1 connected 0-16383\nPS C:\\Dev>\n"})}),"\n",(0,r.jsx)(n.p,{children:"Note that the use of redis-cli is not required; any client compatible with the RESP protocol may be used to execute the aforementioned commands."})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);