"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[3551],{28453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var i=n(96540);const o={},s=i.createContext(o);function r(e){const t=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:r(e.components),i.createElement(s.Provider,{value:t},e.children)}},51325:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"dev/cluster/slot-migration","title":"Migration Overview","description":"In Garnet, slot migration describes the process of reassigning slot ownership and transferring the associated key-value pairs from one primary node to another within a fully operational cluster.","source":"@site/docs/dev/cluster/migration.md","sourceDirName":"dev/cluster","slug":"/dev/cluster/slot-migration","permalink":"/garnet/docs/dev/cluster/slot-migration","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/garnet/tree/main/website/docs/dev/cluster/migration.md","tags":[],"version":"current","frontMatter":{"id":"slot-migration","sidebar_label":"Migration","title":"Migration Overview"},"sidebar":"garnetDocSidebar","previous":{"title":"Sharding","permalink":"/garnet/docs/dev/cluster/sharding"},"next":{"title":"Contributing","permalink":"/garnet/docs/dev/contributing"}}');var o=n(74848),s=n(28453);const r={id:"slot-migration",sidebar_label:"Migration",title:"Migration Overview"},a="Slot Migration Overview",l={},d=[{value:"Migration Data Integrity",id:"migration-data-integrity",level:2},{value:"Migrate KEYS Implementation Details",id:"migrate-keys-implementation-details",level:2},{value:"Migrate SLOTS Details",id:"migrate-slots-details",level:2}];function c(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"slot-migration-overview",children:"Slot Migration Overview"})}),"\n",(0,o.jsxs)(t.p,{children:["In Garnet, slot migration describes the process of reassigning slot ownership and transferring the associated key-value pairs from one primary node to another within a fully operational cluster.\nThis operation allows for efficient resource utilization and load balancing across the cluster when adding or removing nodes.\nThe migration operation is only available in cluster mode.\nSlot migration can be initiated by the owner (referred to as the ",(0,o.jsx)(t.em,{children:"source"})," node) of a given slot, and addressed towards another already known, and trusted primary node (referred to as the ",(0,o.jsx)(t.em,{children:"target"})," node).\nActual data migration can be initiated by using the ",(0,o.jsx)(t.code,{children:"MIGRATE "})," command that operates in two modes: (1) Migrate individual keys (2) Migrate entire slots or range of slots.\nThis page is focused on the slot migration implementation details.\nFor more information about using the associated command refer to the slot migration ",(0,o.jsx)(t.a,{href:"../../cluster/key-migration",children:"user guide"}),"."]}),"\n",(0,o.jsx)(t.h1,{id:"implementation-details",children:"Implementation Details"}),"\n",(0,o.jsx)(t.p,{children:"The implementation of the migration operation is separated into two components:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Command parsing and validation component."}),"\n",(0,o.jsx)(t.li,{children:"Migration session operation and management component."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The first component is responsible for parsing and validating the migration command arguments.\nValidation involves the following:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"Parse every migration option and validate arguments associated with that option."}),"\n",(0,o.jsx)(t.li,{children:"Validate ownership of associated slot that is about to be migrated."}),"\n",(0,o.jsxs)(t.li,{children:["For ",(0,o.jsx)(t.code,{children:"KEYS"})," option, validate that keys to be migrated do not hash across different slots."]}),"\n",(0,o.jsxs)(t.li,{children:["For ",(0,o.jsx)(t.code,{children:"SLOTS/SLOTSRANGE"})," option, validate no slot is referenced multiple times."]}),"\n",(0,o.jsxs)(t.li,{children:["For ",(0,o.jsx)(t.code,{children:"SLOTSRANGE"})," option, make sure a range is defined by a pair of values."]}),"\n",(0,o.jsx)(t.li,{children:"Validate that the target of the migration is known, trusted and has the role of a primary."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["When parsing completes succesfully, a ",(0,o.jsx)(t.em,{children:"migration"})," session is created and executed.\nDepending on the chosen option, the ",(0,o.jsx)(t.em,{children:"migration"})," session executes either as a foreground task (using ",(0,o.jsx)(t.code,{children:"KEYS"})," option) or a background task (",(0,o.jsx)(t.code,{children:"SLOTS/SLOTSRANGE"})," option)."]}),"\n",(0,o.jsx)(t.p,{children:"The second component is separated into the following sub-components:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"MigrationManager"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"MigrateSessionTaskStore"})}),"\n",(0,o.jsx)(t.li,{children:(0,o.jsx)(t.code,{children:"MigrateSession"})}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"MigrationManager"})," is responsible for managing the active ",(0,o.jsx)(t.code,{children:"MigrateSession"})," tasks.\nIt uses the ",(0,o.jsx)(t.code,{children:"MigrateSessionTaskStore"})," to atomically add or remove new instances of ",(0,o.jsx)(t.code,{children:"MigrateSession"}),".\nIt is also responsible for ensuring that existing sessions do not conflict with sessions that are about to be added, by checking if the referred slots in each session do not conflict.\nFinally, it provideds information on the number of ongoing migrate tasks."]}),"\n",(0,o.jsx)(t.h2,{id:"migration-data-integrity",children:"Migration Data Integrity"}),"\n",(0,o.jsx)(t.p,{children:"Since slot migration can be initiated while a Garnet cluster is operational, it needs to be carefully orchestrated to avoid any data integrity issues when clients attempt to write new data.\nIn addition, whatever solution is put forth should not hinder data avaibility while migration is in progress."}),"\n",(0,o.jsxs)(t.p,{children:["Our implementation leverages on the concept of slot-based sharding to ensure that keys mapping to the related slot cannot be modified while a migrate task is active.\nThis is achieved by setting the slot state to ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.strong,{children:"MIGRATING"})})," in the source node.\nThis prevents any write requests though it still allows for reads.\nWrite requests can be issued towards the target node using ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.strong,{children:"ASKING"})}),", though there are not consistency guarantees from Garnet if this option is used.\nGarnet guarantees that no keys can be lost during regular migration (i.e. with using ",(0,o.jsx)(t.em,{children:(0,o.jsx)(t.strong,{children:"ASKING"})}),")."]}),"\n",(0,o.jsxs)(t.p,{children:["Because Garnet operates in a multi-threaded environment, the transition from ",(0,o.jsx)(t.code,{children:"STABLE"})," to ",(0,o.jsx)(t.code,{children:"MIGRATING"})," needs to happen safely, so every thread has a chance to observe that state change.\nThis can happen using epoch protection.\nSpecifically, when a slot transitions to a new state, the segment that implements the actual state transition will have to spin-wait after making the change and return only after all active client sessions have moved to the next epoch."]}),"\n",(0,o.jsx)(t.p,{children:"An excerpt of the code related to epoch protection during slot state transition is shown below.\nEvery client session, before processing an incoming packet, will first acquire the current epoch.\nThis also happens for the client session that issues a slot state transition command (i.e. CLUSTER SETSLOT).\nOn success of updating the local config command, the processing thread of the previous command will perform the following:"}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"release the current epoch (in order to avoid waiting for itselft to transition)."}),"\n",(0,o.jsx)(t.li,{children:"spin-wait until all thread transition to next epoch."}),"\n",(0,o.jsx)(t.li,{children:"re-acquire the next epoch."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"This series of steps ensures that on return, the processing thread guarantees to the command issuer (or the method caller if state transition happens internally), that the state transition is visible to all threads that were active.\nTherefore, any active client session will process subsequent commands considering the new slot state."}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",metastring:'reference title="Wait for Config"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/cluster/Server/ClusterProvider.cs#L271-L296\n"})}),"\n",(0,o.jsxs)(t.p,{children:["During migration, the change in slot state (i.e., ",(0,o.jsx)(t.code,{children:"MIGRATING"}),") is transient from the perspective of the source node.\nThis means that until migration completes the slot is still owned by the source node.\nHowever, because it is necessary to produce ",(0,o.jsx)(t.code,{children:"-ASK"})," redirect messages, the ",(0,o.jsx)(t.em,{children:"workerId"})," is set to the ",(0,o.jsx)(t.em,{children:"workerId"})," of the target node, without bumping the current local epoch (to avoid propagation of this transient update to the whole cluster).\nTherefore, depending on the context of the operation being executed, the actual owner of the node can be determined by accessing ",(0,o.jsx)(t.em,{children:"workerId"})," property, while the target node for migration is determined through ",(0,o.jsx)(t.em,{children:"_workerId"})," variable.\nFor example, the ",(0,o.jsx)(t.code,{children:"CLUSTER NODES"})," will use ",(0,o.jsx)(t.em,{children:"workerId"})," property (through GetSlotRange(",(0,o.jsx)(t.em,{children:"workerId"}),")) since it has to return actual owner of the node even during migration.\nAt the same, time it needs to return all nodes that are in ",(0,o.jsx)(t.code,{children:"MIGRATING"})," or ",(0,o.jsx)(t.code,{children:"IMPORTING"})," state and the node-id associated with that state which can be done by inspecting the ",(0,o.jsx)(t.em,{children:"_workerId"})," variable (through GetSpecialStates(",(0,o.jsx)(t.em,{children:"workerId"}),"))."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",metastring:'reference title="CLUSTER NODES Implementation"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/cluster/Server/ClusterConfig.cs#L499-L521\n"})}),"\n",(0,o.jsx)(t.h2,{id:"migrate-keys-implementation-details",children:"Migrate KEYS Implementation Details"}),"\n",(0,o.jsxs)(t.p,{children:["Using the ",(0,o.jsx)(t.code,{children:"KEYS"})," option, Garnet will iterate through the provided list of keys and migrate them in batches to the target node.\nWhen using this option, the issuer of the migration command will have to make sure that the slot state is set appropriately in the source, and target node.\nIn addition, the issuer has to provide all keys that map to a specific slot either in one call to ",(0,o.jsx)(t.code,{children:"MIGRATE"})," or across multiple call before the migration completes.\nWhen all key-value pairs have migrated to the target node, the issuer has to reset the slot state and assign ownership of the slot to the new node."]}),"\n",(0,o.jsxs)(t.p,{children:[(0,o.jsx)(t.code,{children:"MigrateKeys"})," is the main driver for the migration operation using the ",(0,o.jsx)(t.code,{children:"KEYS"})," option.\nThis method iterates over the list of provided keys and sends them over to the target node.\nThis occurs in the following two phases:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsxs)(t.li,{children:["find all keys provided by ",(0,o.jsx)(t.code,{children:"MIGRATE"})," command and send them over to the ",(0,o.jsx)(t.em,{children:"target"})," node."]}),"\n",(0,o.jsxs)(t.li,{children:["for all remaining keys not found in the main store, lookup into the object store, and if they are found send them over to the ",(0,o.jsx)(t.em,{children:"target"})," node.\nIt is possible that a given key cannot be retrieved from either store, because it might have expired.\nIn that case, execution proceeds to the next available key and no specific error is raised.\nWhen data transmission completes, and depending if COPY option is enabled, ",(0,o.jsx)(t.code,{children:"MigrateKeys"})," deletes the keys from the both stores."]}),"\n"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",metastring:'reference title="MigrateKeys Main Method"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/cluster/Server/Migration/MigrateSessionKeys.cs#L146-L169\n"})}),"\n",(0,o.jsx)(t.h2,{id:"migrate-slots-details",children:"Migrate SLOTS Details"}),"\n",(0,o.jsxs)(t.p,{children:["The ",(0,o.jsx)(t.code,{children:"SLOTS"})," or ",(0,o.jsx)(t.code,{children:"SLOTSRANGE"})," options enables Garnet to migrate a collection of slots and all the associated keys mapping to these slots.\nThese options differ from the ",(0,o.jsx)(t.code,{children:"KEYS"})," options in the following ways:"]}),"\n",(0,o.jsxs)(t.ol,{children:["\n",(0,o.jsx)(t.li,{children:"There is no need to have specific knowledge of the individual keys that are being migrated and how they map to the associated slots. The user simply needs to provide just a slot number."}),"\n",(0,o.jsx)(t.li,{children:"State transitions are handled entirely on the server side."}),"\n",(0,o.jsx)(t.li,{children:"For the migration operation to complete, we have to scan both main and object stores to find and migrate all keys associated with a given slot."}),"\n"]}),"\n",(0,o.jsxs)(t.p,{children:["It might seem, based on the last bullet point from above that the migration operation using ",(0,o.jsx)(t.code,{children:"SLOTS"})," or ",(0,o.jsx)(t.code,{children:"SLOTSRANGE"})," is more expensive, especially if the slot that is being migrated contains only a few keys.\nHowever, it is generally less expensive compared to the ",(0,o.jsx)(t.code,{children:"KEYS"})," option which requires multiple roundtrips between client and server (so any relevant keys can be used as input to the ",(0,o.jsx)(t.code,{children:"MIGRATE"})," command), in addition to having to perform a full scan of both stores."]}),"\n",(0,o.jsxs)(t.p,{children:["As shown in the code excerpt below, the ",(0,o.jsx)(t.code,{children:"MIGRATE SLOTS"})," task will safely transition the state of a slot in the remote node config to ",(0,o.jsx)(t.code,{children:"IMPORTING"})," and the slot state of the local node config to ",(0,o.jsx)(t.code,{children:"MIGRATING"}),", by relying on the epoch protection mechanism as described previously.\nFollowing, it will start migrating the data to the target node in batches.\nOn completion of data migration, the task will conclude with performing next slot state transition where ownership of the slots being migrates will be handed to the target node.\nThe slot ownership exchange becomes visible to the whole cluster by bumping the local node's configuration epoch (i.e. using RelinquishOwnership command).\nFinally, the source node will issue ",(0,o.jsx)(t.code,{children:"CLUSTER SETSLOT NODE"})," to the target node to explicitly make it an owner of the corresponding slot collection.\nThis last step is not necessary and it is used only to speed up the config propagation."]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-csharp",metastring:'reference title="MigrateSlots Background Task"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/cluster/Server/Migration/MigrationDriver.cs#L54-L126\n"})})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}}}]);