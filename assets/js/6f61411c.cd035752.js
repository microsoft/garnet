"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8265],{28453:(e,n,i)=>{i.d(n,{R:()=>s,x:()=>o});var t=i(96540);const r={},a=t.createContext(r);function s(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(a.Provider,{value:n},e.children)}},39475:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"cluster/replication","title":"Replication","description":"Garnet cluster support asynchronous replication following a simple leader-follower (i.e. primary-replica) model.","source":"@site/docs/cluster/replication.md","sourceDirName":"cluster","slug":"/cluster/replication","permalink":"/garnet/docs/cluster/replication","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/garnet/tree/main/website/docs/cluster/replication.md","tags":[],"version":"current","frontMatter":{"id":"replication","sidebar_label":"Replication","title":"Replication","slug":"replication"},"sidebar":"garnetDocSidebar","previous":{"title":"Overview","permalink":"/garnet/docs/cluster/overview"},"next":{"title":"Key Migration","permalink":"/garnet/docs/cluster/key-migration"}}');var r=i(74848),a=i(28453);const s={id:"replication",sidebar_label:"Replication",title:"Replication",slug:"replication"},o="Garnet Cluster Replication",c={},l=[{value:"Replication Performance vs Durability Options",id:"replication-performance-vs-durability-options",level:2},{value:"Querying a Replica",id:"querying-a-replica",level:2},{value:"Checkpointing &amp; Recovery",id:"checkpointing--recovery",level:2},{value:"Replication Information",id:"replication-information",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"garnet-cluster-replication",children:"Garnet Cluster Replication"})}),"\n",(0,r.jsx)(n.p,{children:"Garnet cluster support asynchronous replication following a simple leader-follower (i.e. primary-replica) model.\nThis allows the replica to be exact copies of the primary.\nReplication can be leveraged to scale reads and mitigate the effects of primary failures by promoting replicas to primary.\nIn this page, we present an overview of the replication protocol and discuss the different persistent/consistency options available to the cluster operator."}),"\n",(0,r.jsx)(n.h1,{id:"garnet-replication-properties",children:"Garnet Replication Properties"}),"\n",(0,r.jsx)(n.p,{children:"Garnet cluster implements replication through log shipping.\nPrimaries utilize the Append-Only-File (AOF) to record insert/update operations.\nA dedicated background task iterates through the log pages and transmits them in bulk to the corresponding replica.\nReplicas will iterate through the received log pages, replay all insert/update operations in order, and generate their own AOF.\nPrimaries are generally free to take arbitrary checkpoints.\nWhen the primary takes a checkpoint, it will insert a checkpoint marker into the AOF.\nAs a side effect of this, when any of the attached replicas receive the corresponding records, it will initiate its own checkpoint.\nFor this reason, an exact version of the data is identified from the following triplet:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"[replication-id, checkpoint-version, replication-offset]\n"})}),"\n",(0,r.jsx)(n.p,{children:"Allowing replicas to take their own checkpoints speeds up the recovery process because in the common case replicas can recover from their own checkpoint and replay their AOF before connecting to their primary and resuming synchronization.\nOn rare occasions, the replica must perform a full synchronization by retrieving the latest checkpoint from the primary.\nPartial synchronization involves recovering from a local checkpoint (if any) and replaying only the primary's AOF log after the corresponding Checkpoint Covered Replication Offset (CCRO).\nFull synchronization involves retrieving the latest primary checkpoint and recovering from it before starting to accept any new AOF log records."}),"\n",(0,r.jsx)(n.p,{children:"The replica decides if it will perform either type of synchronization as follows:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"If the primary replication-id differs from the replica replication-id, a full synchronization must occur."}),"\n",(0,r.jsx)(n.li,{children:"If the primary checkpoint version differs from the replica checkpoint, a full synchronization must occur."}),"\n",(0,r.jsx)(n.li,{children:"If none of the above conditions are true, replica can recover from local checkpoint and then continue replaying from the AOF offsets that is missing."}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"replication-performance-vs-durability-options",children:"Replication Performance vs Durability Options"}),"\n",(0,r.jsx)(n.p,{children:"Under normal workload the AOF log will keep growing with every insert/update operation until a checkpoint is taken.\nNewly added AOF log records will initially reside in memory and then flushed to disk as new records are being added.\nFor write heavye workloads, this could severely impact query performance at the primary.\nIn addition, newly configured replicas, added to the cluster, could face longer synchronization times since they have to replay the AOF log records starting from the corresponding CCRO."}),"\n",(0,r.jsx)(n.p,{children:"The cluster operator can choose between various replication options to achieve a trade-off between performance and durability.\nA summary of these options is shown below:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Fast AOF Truncation (FAT)\nThis option forces the primary to aggressively truncate the AOF so it does not spill into disk. It can be used in combination with aof-memory option which determines the maximum AOF memory buffer size.\nWhen a replica attaches to a primary with FAT turned on, the AOF is not guaranteed to be truncated which may result in writes being lost.\nTo overcome this issue FAT should be used with ODC."}),"\n",(0,r.jsx)(n.li,{children:"On Demand Checkpoint (ODC)\nThis option forces the primary to take a checkpoint if no checkpoint is available when replica tries to attach and recover. If a checkpoint becomes or was availalbe and the CCRO has not been truncated, then\nthe primary will lock it to prevent truncation while a replica is recovering. In this case, they AOF log could spill to disk as the AOF in memory buffer becomes full.\nUnder normal operation, the AOF is truncated and no spilling to disk will happen."}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Using the aforementioned options, we guarantee that no writes are lost while a replica is attaching and replication remains highly performant.\nHowever, due to the asynchronous nature of replication, if a primary goes down before unexpectedly, the replicas might have not received the latest AOF log records, resulting in lost writes."}),"\n",(0,r.jsx)(n.h1,{id:"creating-a-garnet-cluster-with-replication",children:"Creating a Garnet Cluster with Replication"}),"\n",(0,r.jsx)(n.p,{children:"The process of setting up a cluster with replication is similar to setting up a regular cluster while also enabling the aof option.\nThis should done for every instance in the cluster."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"GarnetServer.exe --cluster --checkpointdir='data/' --aof\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The AOF log file is stored within the checkpointdir folder which by default is the working folder.\nBy default every Garnet instance will take the role of an empty primary.\nThe cluster operator has to initially assign the slots to a subset of those primaries.\nThe rest of the instances can be coverted to replicas by using the ",(0,r.jsx)(n.code,{children:"CLUSTER REPLICATE"})," command.\nAn example of setting up a cluster with a single primary and 2 replicas is shown below:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'PS C:\\Dev> redis-cli -h 192.168.1.26 -p 7000 cluster myid\n"15373cf386c5090a5f8a25f819c96b04a756381c"\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7000 cluster addslotsrange 0 16383\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7000 cluster set-config-epoch 1\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7001 cluster set-config-epoch 2\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7002 cluster set-config-epoch 3\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7000 cluster meet 192.168.1.26 7001\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7000 cluster meet 192.168.1.26 7002\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7001 cluster replicate 15373cf386c5090a5f8a25f819c96b04a756381c\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7002 cluster replicate 15373cf386c5090a5f8a25f819c96b04a756381c\nOK\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7000 cluster nodes\n15373cf386c5090a5f8a25f819c96b04a756381c 192.168.1.26:7000@17000,DESKTOP-BT8KHK1 myself,master - 0 0 1 connected 0-16383\n5868649e4205bf6ea97e4b7a12f101c3aed96b71 192.168.1.26:7001@17001,DESKTOP-BT8KHK1 slave 15373cf386c5090a5f8a25f819c96b04a756381c 0 0 4 connected\n947692ec7fb4a919ae7d0d7e314e9dcbcbd99774 192.168.1.26:7002@17002,DESKTOP-BT8KHK1 slave 15373cf386c5090a5f8a25f819c96b04a756381c 0 0 5 connected\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7001 cluster nodes\n5868649e4205bf6ea97e4b7a12f101c3aed96b71 192.168.1.26:7001@17001,DESKTOP-BT8KHK1 myself,slave 15373cf386c5090a5f8a25f819c96b04a756381c 0 0 4 connected\n15373cf386c5090a5f8a25f819c96b04a756381c 192.168.1.26:7000@17000,DESKTOP-BT8KHK1 master - 0 0 1 connected 0-16383\n947692ec7fb4a919ae7d0d7e314e9dcbcbd99774 192.168.1.26:7002@17002,DESKTOP-BT8KHK1 slave 15373cf386c5090a5f8a25f819c96b04a756381c 0 0 5 connected\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7002 cluster nodes\n947692ec7fb4a919ae7d0d7e314e9dcbcbd99774 192.168.1.26:7002@17002,DESKTOP-BT8KHK1 myself,slave 15373cf386c5090a5f8a25f819c96b04a756381c 0 0 5 connected\n15373cf386c5090a5f8a25f819c96b04a756381c 192.168.1.26:7000@17000,DESKTOP-BT8KHK1 master - 0 0 1 connected 0-16383\n5868649e4205bf6ea97e4b7a12f101c3aed96b71 192.168.1.26:7001@17001,DESKTOP-BT8KHK1 slave 15373cf386c5090a5f8a25f819c96b04a756381c 0 0 4 connected\n'})}),"\n",(0,r.jsx)(n.p,{children:"There is not limit on the number of replicas attached to a given primary.\nCurrently, we do not support chained replication."}),"\n",(0,r.jsx)(n.h2,{id:"querying-a-replica",children:"Querying a Replica"}),"\n",(0,r.jsxs)(n.p,{children:["By default replicas only serve read queries but can also be configure to process write requests.\nThis option is available by issuing once ",(0,r.jsx)(n.code,{children:"READWRITE"})," command just before executing any write operation in a single client session.\nIssuing ",(0,r.jsx)(n.code,{children:"READONLY"})," will toggle back to serving read queries."]}),"\n",(0,r.jsxs)(n.p,{children:["If a replica is set to process read-only queries, it will respond with ",(0,r.jsx)(n.em,{children:"-MOVED"})," to any write requests, redirecting them to the primary that is replicating."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:'PS C:\\Dev> redis-cli -h 192.168.1.26 -p 7001 -c\n192.168.1.26:7001> set x 1234\n-> Redirected to slot [16287] located at 192.168.1.26:7000\nOK\n192.168.1.26:7000> set x 1234\nOK\n192.168.1.26:7000> get x\n"1234"\n192.168.1.26:7000> exit\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7001 -c\n192.168.1.26:7001> get x\n"1234"\n192.168.1.26:7001> exit\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7002\n192.168.1.26:7002> get x\n"1234"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"checkpointing--recovery",children:"Checkpointing & Recovery"}),"\n",(0,r.jsxs)(n.p,{children:["As noted above primaries can take arbirtrary checkpoints and propagate that information to the replicas.\nReplicas will identify the checkpoint record in the AOF file and initiate a checkpoint on its own.\nTaking a checkpoint at the primary is as easy as calling ",(0,r.jsx)(n.code,{children:"SAVE"})," or ",(0,r.jsx)(n.code,{children:"BGSAVE"}),"command.\nWhen the checkpoint operation completes, it is recorded into the AOF log.\nThe replicas will receive that record and initiate its own checkpoint."]}),"\n",(0,r.jsx)(n.p,{children:"An example of checkpoint propagation is shown below:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"PS C:\\Dev> redis-cli -h 192.168.1.26 -p 7000\n192.168.1.26:7000> lastsave\n(integer) 0\n192.168.1.26:7000> bgsave\nBackground saving started\n192.168.1.26:7000> lastsave\n(integer) 1706555027\n192.168.1.26:7000> exit\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7001\n192.168.1.26:7001> lastsave\n(integer) 1706555029\n192.168.1.26:7001> exit\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7002\n192.168.1.26:7002> lastsave\n(integer) 1706555028\n192.168.1.26:7002>\n"})}),"\n",(0,r.jsx)(n.h2,{id:"replication-information",children:"Replication Information"}),"\n",(0,r.jsx)(n.p,{children:"The system admin can track the progress of replication by retrieving the replication information section using info replication command.\nA summary of the available fields returned is shown below:"}),"\n",(0,r.jsx)(n.p,{children:"role: role of the instance being queried\nconnected_slaves: number of replicas connected to the instance.\nmaster_failover_state:  The state of an ongoing failover, if any.\nmaster_replid: replication id of this Garnet server instance.\nmaster_replid2: secondary replication id (currently not being used).\nmaster_repl_offset: current primary AOF offset.\nstore_current_safe_aof_address: AOF address covered by latest checkpoint\nstore_recovered_safe_aof_address:  AOF address covered by the recovered checkpoint\nobject_store_current_safe_aof_address: AOF address covered by latest checkpoint of object store\nobject_store_recovered_safe_aof_address: AOF address covered by recovered checkpoint of object store"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-bash",children:"192.168.1.26:7000> info replication\n# Replication\nrole:master\nconnected_slaves:2\nmaster_failover_state:no-failover\nmaster_replid:dd194cb04b18b31373157e22d0ab36df9cc6a04a\nmaster_replid2:\nmaster_repl_offset:136\nsecond_repl_offset:136\nstore_current_safe_aof_address:0\nstore_recovered_safe_aof_address:0\nobject_store_current_safe_aof_address:0\nobject_store_recovered_safe_aof_address:0\nslave0:ip=192.168.1.26,port=7001,state=online,offset=136,lag=0\nslave1:ip=192.168.1.26,port=7002,state=online,offset=136,lag=0\n192.168.1.26:7000> exit\nPS C:\\Dev> redis-cli -h 192.168.1.26 -p 7001\n192.168.1.26:7001> info replication\n# Replication\nrole:slave\nconnected_slaves:0\nmaster_failover_state:no-failover\nmaster_replid:dd194cb04b18b31373157e22d0ab36df9cc6a04a\nmaster_replid2:\nmaster_repl_offset:136\nsecond_repl_offset:136\nstore_current_safe_aof_address:0\nstore_recovered_safe_aof_address:0\nobject_store_current_safe_aof_address:0\nobject_store_recovered_safe_aof_address:0\nmaster_host:192.168.1.26\nmaster_port:7000\nmaster_link_status:up\nmaster_last_io_seconds_ago:1\nmaster_sync_in_progress:False\nslave_read_repl_offset:136\nslave_priority:100\nslave_read_only:1\nreplica_announced:1\n192.168.1.26:7001>\n"})}),"\n",(0,r.jsx)(n.h1,{id:"diskless-replication",children:"Diskless Replication"}),"\n",(0,r.jsx)(n.p,{children:"When AOF gets truncated, full synchronization requires taking a checkpoint and sending that checkpoint over to the attaching replica.\nThis operation can be expensive because it involves multiple I/O operations at the primary and replica.\nFor this reason, we added a variant of full synchronization called diskless replication.\nThis is implemented using a streaming checkpoint that allows clients to continue issuing read and writes at the primary while attaching replicas synchronize.\nTo enable diskless replication the server needs to be started with the following flags"}),"\n",(0,r.jsx)(n.p,{children:"--repl-diskless-sync=true\nThis is used to enable diskless replication"}),"\n",(0,r.jsx)(n.p,{children:"--repl-diskless-sync-delay=<seconds>.\nThis is used to determine how many seconds to wait before starting the full sync, in order to give the opportunity to multiple replicas to attach and receive the streaming checkpoint."}),"\n",(0,r.jsx)(n.p,{children:"There is no additional requirements to that of using the aforementioned flags in order to leverage diskless replication.\nThe APIs for mapping replicas remain the same (i.e. CLUSTER REPLICATE, REPLICAOF etc.)."}),"\n",(0,r.jsx)(n.p,{children:"Note that diskless replication does not take an actual checkpoint.\nHence every time a full sync is performed, the AOF is not automatically truncated (unless FAT flag is used).\nThis happens to ensure durability in the event of a failure which will not be possible if the AOF gets truncated without a persistent checkpoint.\nHowever, the store version gets incremented to ensure consistency across different instances that may be fully synced at different times.\nUsers can still utilize SAVE/BGSAVE commands or --aof-size-limit to periodically take a checkpoint and safely truncates the AOF."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}}}]);