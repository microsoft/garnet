"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[6674],{28453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>a});var s=n(96540);const r={},i=s.createContext(r);function o(e){const t=s.useContext(i);return s.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:t},e.children)}},41646:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"dev/cluster/sharding","title":"Sharding Overview","description":"Cluster Configuration","source":"@site/docs/dev/cluster/sharding.md","sourceDirName":"dev/cluster","slug":"/dev/cluster/sharding","permalink":"/garnet/docs/dev/cluster/sharding","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/garnet/tree/main/website/docs/dev/cluster/sharding.md","tags":[],"version":"current","frontMatter":{"id":"sharding","sidebar_label":"Sharding","title":"Sharding Overview"},"sidebar":"garnetDocSidebar","previous":{"title":"Cluster Overview","permalink":"/garnet/docs/dev/cluster/overview"},"next":{"title":"Migration","permalink":"/garnet/docs/dev/cluster/slot-migration"}}');var r=n(74848),i=n(28453);const o={id:"sharding",sidebar_label:"Sharding",title:"Sharding Overview"},a="Sharding Overview",d={},c=[{value:"Cluster Configuration",id:"cluster-configuration",level:2},{value:"Configuration Update Propagation",id:"configuration-update-propagation",level:3},{value:"Slot Verification",id:"slot-verification",level:2},{value:"Redirection Messages",id:"redirection-messages",level:2}];function l(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"sharding-overview",children:"Sharding Overview"})}),"\n",(0,r.jsx)(t.h2,{id:"cluster-configuration",children:"Cluster Configuration"}),"\n",(0,r.jsx)(t.p,{children:"Every running cluster instance maintains a local copy of the cluster configuration.\nThis copy maintains information about the known cluster workers and the related slot assignment.\nBoth pieces of information are represented using an array of structs as shown below.\nChanges to the local copy are communicated to the rest of the cluster nodes through gossiping."}),"\n",(0,r.jsxs)(t.p,{children:["Note that information related to the node characteristics can be updated only by the node itself by issuing the relevant cluster commands.\nFor example, a node cannot become a ",(0,r.jsx)(t.strong,{children:"REPLICA"})," by receiving a gossip message.\nIt can only change its current role only after receiving a ",(0,r.jsx)(t.code,{children:"CLUSTER REPLICATE"})," request.\nWe follow this constrain to avoid having to deal with cluster misconfiguration in the event of network partitions.\nThis convention also extends to slot assignment, which is managed through direct requests to cluster instances made using the ",(0,r.jsx)(t.code,{children:"CLUSTER [ADDSLOTS|DELSLOTS]"})," and ",(0,r.jsx)(t.code,{children:"CLUSTER [ADDSLOTSRANGE|DELSLOTSRANGE]"})," commands."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'reference title="Hashlot & Worker Array Declaration"',children:"https://github.com/microsoft/garnet/blob/8856dc3990fb0863141cb902bbf64c13202d5f85/libs/cluster/Server/ClusterConfig.cs#L16-L42\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Initially, the cluster nodes are empty, taking the role of a ",(0,r.jsx)(t.strong,{children:"PRIMARY"}),", having no assigned slots and with no knowledge of any other node in the cluster.\nThe local node contains information only about itself stored at workers[1] while workers[0] is reserved for special use to indicate unassigned slots.\nGarnet cluster nodes are connected to each other through the ",(0,r.jsx)(t.code,{children:"CLUSTER MEET"}),"  command which generates a special kind of gossip message.\nThis message forces a remote node to add the sender to its list of trusted nodes.\nRemote nodes are stored in any order starting from workers[2]."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'reference title="Worker Definition"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/cluster/Server/Worker.cs#L28-L85\n"})}),"\n",(0,r.jsx)(t.p,{children:"Information about the individual slot assignment is captured within the configuration object using an array of HashSlot struct type.\nIt maintains information about the slot state and corresponding owner.\nThe slot owner is represented using the offset in the local copy of the workers array.\nThe slot state is used to determine how to serve requests for keys that map to the relevant slot."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'reference title="HashSlot Definition"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/cluster/Server/HashSlot.cs#L43-L61\n"})}),"\n",(0,r.jsxs)(t.p,{children:["At cluster startup slots are are unassigned, hence their initial state is set to ",(0,r.jsx)(t.strong,{children:"OFFLINE"})," and workerId to 0.\nWhen a slot is assigned to a specific node, its state is set to ",(0,r.jsx)(t.strong,{children:"STABLE"})," and workerId (from the perspective of the local configuration copy) to the corresponding offset of the owner node in workers array.\nOwners of a slot can perform read/write and migrate operations on the data associated with that specific slot.\nReplicas can serve read requests only for keys mapped to slots owned by their primary."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'reference title="SlotState Definition"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/cluster/Server/HashSlot.cs#L11-L37\n"})}),"\n",(0,r.jsx)(t.h3,{id:"configuration-update-propagation",children:"Configuration Update Propagation"}),"\n",(0,r.jsxs)(t.p,{children:["A given node will accept gossip messages from trusted nodes.\nThe gossip message will contain a serialized byte array representation which represents a snapshot of the remote node's local configuration.\nThe receiving node will try to atomically merge the incoming configuration to its local copy by comparing the relevant workers' configuration epoch.\nHence any changes to the cluster's configuration can happen at the granularity of a single worker.\nWe leverage this mechanism to control when local updates become visiable to the rest of the cluster.\nThis is extremely useful for operations that are extended over a long duration and consist of several phases (e.g. ",(0,r.jsx)(t.a,{href:"slot-migration",children:"data migration"}),").\nSuch operations are susceptible to interruptions and require protective measures to prevent any compromise of data integrity."]}),"\n",(0,r.jsxs)(t.p,{children:["As mentioned previously, local updates are propagated through gossiping which can operate in broadcast mode or gossip sampling mode.\nIn the former case, we broadcast the configuration to all nodes in the cluster periodically, while in the latter case we pick randomly a subset of nodes to gossip with.\nThis can be configured at server start-up by using ",(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"--gossip-sp"})})," flag."]}),"\n",(0,r.jsx)(t.h2,{id:"slot-verification",children:"Slot Verification"}),"\n",(0,r.jsxs)(t.p,{children:["RESP data commands operate either on a single key or a collection of keys.\nIn addition, they can be classified either as readonly (e.g. ",(0,r.jsx)(t.em,{children:"GET"})," mykey) or read-write (e.g. ",(0,r.jsx)(t.em,{children:"SET"})," mykey foo).\nWhen operating in cluster mode and before processing any command Garnet performs an extra slot verification step.\nSlot verification involves inspecting the key or keys associated with a given command and validating that it maps to a slot that can be served by the node receiving the associated request.\nGarnet primary nodes can serve ",(0,r.jsx)(t.em,{children:"read"})," and ",(0,r.jsx)(t.em,{children:"read-write"})," requests for slots that they own, while Garnet replica nodes can only serve read requests for slots that their primary owns.\nOn failure of the slot verification step, the corresponding command will not be processed and the slot verification method will write a redirection message directly to the network buffer."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-csharp",metastring:'reference title="Slot Verification Methods"',children:"https://github.com/microsoft/garnet/blob/951cf82c120d4069e940e832db03bfa018c688ea/libs/server/Cluster/IClusterSession.cs#L47-L67\n"})}),"\n",(0,r.jsx)(t.h2,{id:"redirection-messages",children:"Redirection Messages"}),"\n",(0,r.jsxs)(t.p,{children:["From the perspective of a single node, any requests for keys mapping towards an unassigned slot will result in ",(0,r.jsx)(t.code,{children:"-CLUSTERDOWN Hashlot not served"})," message.\nFor a single key request an assigned slot is considered ",(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"LOCAL"})})," if the receiving node owns that slot, otherwise it is classified as a ",(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"REMOTE"})})," slot since it is owned by a remote node.\nIn the table below, we provide a summary of the different redirection messages that are generated depending on the slot state and the type of operation being performed.\nRead-only and read-write requests for a specific key mapping to a ",(0,r.jsx)(t.em,{children:(0,r.jsx)(t.strong,{children:"REMOTE"})})," slot will result in ",(0,r.jsx)(t.code,{children:"-MOVED <slot> <address>:<port>"})," redirection message, pointing to the endpoint that claims ownership of the associated slot.\nA slot can also be in a special state such as ",(0,r.jsx)(t.code,{children:"IMPORTING"})," or ",(0,r.jsx)(t.code,{children:"MIGRATING"}),".\nThese states are used primarily during slot migration, with the ",(0,r.jsx)(t.code,{children:"IMPORTING"})," state assigned to the slot map of the target node and the ",(0,r.jsx)(t.code,{children:"MIGRATING"})," state to the slot map of the source node.\nShould a slot be in the ",(0,r.jsx)(t.code,{children:"MIGRATING"})," state and the key is present (meaning it has not yet been migrated), the read requests can continue to be processed as usual.\nOtherwise the receiving node (for both read-only and read-write requests) will return ",(0,r.jsx)(t.code,{children:"-ASK <slot> <address>:<port>"})," redirection message pointing to the target node.\nNote read-write key requests on existing keys are not allowed in order to ensure data integrity during migration."]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Operation/State"}),(0,r.jsx)(t.th,{children:"ASSIGNED LOCAL"}),(0,r.jsx)(t.th,{children:"ASSIGNED REMOTE"}),(0,r.jsx)(t.th,{children:"MIGRATING EXISTS"}),(0,r.jsx)(t.th,{children:"MIGRATING ~EXISTS"}),(0,r.jsx)(t.th,{children:"IMPORTING ASKING"}),(0,r.jsx)(t.th,{children:"IMPORTING ~ASKING"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Read-Only"}),(0,r.jsx)(t.td,{children:"OK"}),(0,r.jsx)(t.td,{children:"-MOVED"}),(0,r.jsx)(t.td,{children:"OK"}),(0,r.jsx)(t.td,{children:"-ASK"}),(0,r.jsx)(t.td,{children:"OK"}),(0,r.jsx)(t.td,{children:"-MOVED"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"Read-Write"}),(0,r.jsx)(t.td,{children:"OK"}),(0,r.jsx)(t.td,{children:"-MOVED"}),(0,r.jsx)(t.td,{children:"-MIGRATING"}),(0,r.jsx)(t.td,{children:"-ASK"}),(0,r.jsx)(t.td,{children:"OK"}),(0,r.jsx)(t.td,{children:"-MOVED"})]})]})]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}}}]);