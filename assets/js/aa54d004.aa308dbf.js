"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6690],{26794:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>a,contentTitle:()=>c,default:()=>h,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"dev/processing","title":"Processing Layer","description":"Messages to Garnet server are processed once the networking layer reads the incoming message and passes it to the RespServerSession class.","source":"@site/docs/dev/processing.md","sourceDirName":"dev","slug":"/dev/processing","permalink":"/garnet/docs/dev/processing","draft":false,"unlisted":false,"editUrl":"https://github.com/microsoft/garnet/tree/main/website/docs/dev/processing.md","tags":[],"version":"current","frontMatter":{"id":"processing","sidebar_label":"Processing Layer","title":"Processing Layer"},"sidebar":"garnetDocSidebar","previous":{"title":"Network Layer","permalink":"/garnet/docs/dev/network"},"next":{"title":"Garnet API","permalink":"/garnet/docs/dev/garnet-api"}}');var t=n(74848),o=n(28453);const i={id:"processing",sidebar_label:"Processing Layer",title:"Processing Layer"},c="Processing Layer",a={},d=[];function l(e){const s={a:"a",br:"br",code:"code",h1:"h1",header:"header",li:"li",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.header,{children:(0,t.jsx)(s.h1,{id:"processing-layer",children:"Processing Layer"})}),"\n",(0,t.jsxs)(s.p,{children:["Messages to Garnet server are processed once the networking layer reads the incoming message and passes it to the ",(0,t.jsx)(s.code,{children:"RespServerSession"})," class."]}),"\n",(0,t.jsxs)(s.p,{children:["Within a session, the ",(0,t.jsx)(s.code,{children:"TryConsumeMessages"})," method is responsible for processing the incoming messages by"]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsx)(s.li,{children:"Measuring and tracking latency of processing along with bytes consumed and operations performed."}),"\n",(0,t.jsxs)(s.li,{children:["Process messages further using the ",(0,t.jsx)(s.code,{children:"ProcessMessages"})," method."]}),"\n",(0,t.jsx)(s.li,{children:"Acts as the catch all for any exceptions occurring during message processing. This ensures that the server continues to run, even if processing of a message causes a critical unhandled exception and all resources are being freed up correctly."}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"ProcessMessages"})," method does a fast parsing of the incoming data to quickly identify the right command type. Based on the type of the command, further processing is performed by one of the below methods."]}),"\n",(0,t.jsxs)(s.ul,{children:["\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ProcessBasicCommands"}),(0,t.jsx)(s.br,{}),"\n","This includes commands like GET, SET, DEL, RENAME, EXISTS, EXPIRE, TTL, INCR, PING, MULTI, EXEC, QUIT, etc."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ProcessArrayCommands"}),(0,t.jsx)(s.br,{}),"\n","If it is not one of the basic commands above, further parsing is performed to check if the incoming data matches any of the array commands - commands related to multiple keys, commands that operate using Object store, etc. like MGET, MSET, KEYS, SCAN, ZADD, ZREM, LPUSH, HSET, etc."]}),"\n"]}),"\n",(0,t.jsxs)(s.li,{children:["\n",(0,t.jsxs)(s.p,{children:[(0,t.jsx)(s.code,{children:"ProcessOtherCommands"}),(0,t.jsx)(s.br,{}),"\n","This caters to processing rest of the commands including ",(0,t.jsx)(s.code,{children:"ProcessAdminCommands"})," (for commands like AUTH, CONFIG, CLUSTER, etc), custom commands, custom transactions, etc."]}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(s.p,{children:["This method also tracks session level metrics like the number of read, write and total commands that have been processed.\nTransaction related operations are also performed here like calls to skip, start, stop and process commands within. See ",(0,t.jsx)(s.a,{href:"/garnet/docs/dev/transactions",children:"transactions page"})," for more details."]}),"\n",(0,t.jsx)(s.p,{children:"Once the initial command is identified as described above, further processing is performed by command specific methods."}),"\n",(0,t.jsxs)(s.p,{children:["Next step of processing in a command specific manner is performed by methods named like Network[Command]. These methods are responsible for reading and parsing of command\nspecific parameters from the incoming network buffer. Once the necessary arguments are parsed, they invoke the underlying storage layer method for performing the command operation. Then, they also write the response message back to the client in the right RESP format. For this, they use the buffer created by the network sender.\nFor example, see ",(0,t.jsx)(s.code,{children:"NetworkIncrement"})," method in ",(0,t.jsx)(s.code,{children:"BasicCommands.cs"}),"."]}),"\n",(0,t.jsxs)(s.p,{children:["The storage layer methods perform the actual processing logic of the command. They do utilize the underlying Tsavorite layer's APIs for performing operations like Read, RMW, Upset, Delete. Also, additional processing logic is implemented in the Tsavorite callbacks.\nFor example, see ",(0,t.jsx)(s.code,{children:"Increment"})," method in ",(0,t.jsx)(s.code,{children:"MainStoreOps.cs"})," and related methods in ",(0,t.jsx)(s.code,{children:"MainStoreFunctions"}),"."]})]})}function h(e={}){const{wrapper:s}={...(0,o.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},28453:(e,s,n)=>{n.d(s,{R:()=>i,x:()=>c});var r=n(96540);const t={},o=r.createContext(t);function i(e){const s=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function c(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),r.createElement(o.Provider,{value:s},e.children)}}}]);