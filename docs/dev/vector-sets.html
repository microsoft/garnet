<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-dev/vector-sets" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Vector Sets | Garnet</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://microsoft.github.io/garnet/docs/dev/vector-sets"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Vector Sets | Garnet"><meta data-rh="true" name="description" content="Garnet has partial support for Vector Sets, implemented on top of the DiskANN project."><meta data-rh="true" property="og:description" content="Garnet has partial support for Vector Sets, implemented on top of the DiskANN project."><link data-rh="true" rel="icon" href="/garnet/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://microsoft.github.io/garnet/docs/dev/vector-sets"><link data-rh="true" rel="alternate" href="https://microsoft.github.io/garnet/docs/dev/vector-sets" hreflang="en"><link data-rh="true" rel="alternate" href="https://microsoft.github.io/garnet/docs/dev/vector-sets" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Vector Sets","item":"https://microsoft.github.io/garnet/docs/dev/vector-sets"}]}</script><link rel="alternate" type="application/rss+xml" href="/garnet/blog/rss.xml" title="Garnet RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/garnet/blog/atom.xml" title="Garnet Atom Feed">




<script>!function(t,e,n,c,a,r,s){t[n]=t[n]||function(){(t[n].q=t[n].q||[]).push(arguments)},(r=e.createElement(c)).async=1,r.src="https://www.clarity.ms/tag/loh6v65ww5",(s=e.getElementsByTagName(c)[0]).parentNode.insertBefore(r,s)}(window,document,"clarity","script")</script><link rel="stylesheet" href="/garnet/assets/css/styles.a0a59612.css">
<script src="/garnet/assets/js/runtime~main.e7179374.js" defer="defer"></script>
<script src="/garnet/assets/js/main.3523f085.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||"light"),document.documentElement.setAttribute("data-theme-choice",t||"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/garnet/img/garnet-logo-diamond.png"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/garnet/"><div class="navbar__logo"><img src="/garnet/img/garnet-logo-diamond.png" alt="Garnet Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/garnet/img/garnet-logo-diamond.png" alt="Garnet Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Garnet</b></a><a class="navbar__item navbar__link" href="/garnet/docs">Docs</a><a class="navbar__item navbar__link" href="/garnet/blog">Blog</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/microsoft/garnet" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input searchInput_YFbd" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/azure/api-compatibility"><span title="azure" class="categoryLinkLabel_W154">azure</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/benchmarking/overview"><span title="benchmarking" class="categoryLinkLabel_W154">benchmarking</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/cluster/key-migration"><span title="cluster" class="categoryLinkLabel_W154">cluster</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/commands/acl"><span title="commands" class="categoryLinkLabel_W154">commands</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/garnet/docs/dev/cluster/slot-migration"><span title="dev" class="categoryLinkLabel_W154">dev</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/garnet/docs/dev/cluster/slot-migration"><span title="cluster" class="categoryLinkLabel_W154">cluster</span></a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/cluster"><span title="Cluster Mode" class="linkLabel_WmDU">Cluster Mode</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/code-structure"><span title="Code Structure" class="linkLabel_WmDU">Code Structure</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/collection-broker"><span title="Collection Broker" class="linkLabel_WmDU">Collection Broker</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/configuration"><span title="Configuration" class="linkLabel_WmDU">Configuration</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/contributing"><span title="Contributing" class="linkLabel_WmDU">Contributing</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/custom-commands"><span title="Custom Commands" class="linkLabel_WmDU">Custom Commands</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/garnet-api"><span title="Garnet API" class="linkLabel_WmDU">Garnet API</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/multi-db"><span title="Logical Databases" class="linkLabel_WmDU">Logical Databases</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/network"><span title="Network Layer" class="linkLabel_WmDU">Network Layer</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/onboarding"><span title="Onboarding" class="linkLabel_WmDU">Onboarding</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/processing"><span title="Processing Layer" class="linkLabel_WmDU">Processing Layer</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/garnet/docs/dev/transactions"><span title="Transactions" class="linkLabel_WmDU">Transactions</span></a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" tabindex="0" href="/garnet/docs/dev/tsavorite/epoch"><span title="tsavorite" class="categoryLinkLabel_W154">tsavorite</span></a></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/garnet/docs/dev/vector-sets"><span title="Vector Sets" class="linkLabel_WmDU">Vector Sets</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/extensions/module"><span title="extensions" class="categoryLinkLabel_W154">extensions</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/getting-started"><span title="getting-started" class="categoryLinkLabel_W154">getting-started</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/research/papers"><span title="research" class="categoryLinkLabel_W154">research</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/garnet/docs/welcome/about-us"><span title="welcome" class="categoryLinkLabel_W154">welcome</span></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/garnet/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">dev</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Vector Sets</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>Overview</h1></header>
<p>Garnet has partial support for Vector Sets, implemented on top of the <a href="https://www.nuget.org/packages/diskann-garnet/" target="_blank" rel="noopener noreferrer" class="">DiskANN project</a>.</p>
<p>This data type is very strange when compared to others Garnet supports.</p>
<blockquote>
<p>[!IMPORTANT]
The DiskANN link needs to be updated once OSS&#x27;d.</p>
</blockquote>
<h1>Design</h1>
<p>Vector Sets are a combination of one &quot;index&quot; key, which stores metadata and a pointer to the DiskANN data structure, and many &quot;element&quot; keys, which store vectors/quantized vectors/attributes/etc.  All Vector Set keys are kept in the main store, but only the index key is visible - this is accomplished by putting all element keys in different namespaces.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="global-metadata">Global Metadata<a href="#global-metadata" class="hash-link" aria-label="Direct link to Global Metadata" title="Direct link to Global Metadata" translate="no">​</a></h2>
<p>In order to track allocated Vector Sets (and their respective hash slots), in progress cleanups, in progress migrations - we keep a single <code>ContextMetadata</code> struct under the empty key in namespace 0.</p>
<p>This is loaded and cached on startup, and updated (both in memory and in Tsavorite) whenever a Vector Set is created or deleted.  Simple locking (on the <code>VectorManager</code> instance) is used to serialize these updates as they should be rare.</p>
<blockquote>
<p>[!IMPORTANT]
Today <code>ContextMetadata</code> can track only 64 Vector Sets in some state of creation or cleanup.</p>
<p>The practical limit is actually 31, because context must be &lt; 256, divisible by 8, and not 0 (which is reserved).</p>
<p>This limitation will be lifted eventually, perhaps after Store V2 lands.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="indexes">Indexes<a href="#indexes" class="hash-link" aria-label="Direct link to Indexes" title="Direct link to Indexes" translate="no">​</a></h2>
<p>The index key (represented by the <code>Index</code> struct) contains the following data:</p>
<ul>
<li class=""><code>ulong Context</code> - used to derive namespaces, detailed below</li>
<li class=""><code>ulong IndexPtr</code> - a pointer to the DiskANN data structure, note this may be <em>dangling</em> after <a href="#recovery" class="">recovery</a> or <a href="#replication" class="">replication</a></li>
<li class=""><code>uint Dimensions</code> - the expected dimension of vectors in commands targeting the Vector Set, this is inferred based on the <code>VADD</code> that creates the Vector Set</li>
<li class=""><code>uint ReduceDims</code> - if a Vector Set was created with the <code>REDUCE</code> option that value, otherwise zero<!-- -->
<ul>
<li class="">
<blockquote>
<p>[!NOTE]
Today this ignored except for validation purposes, eventually DiskANN will use it.</p>
</blockquote>
</li>
</ul>
</li>
<li class=""><code>uint NumLinks</code> - the <code>M</code> used to create the Vector Set, or the default value of 16 if not specified</li>
<li class=""><code>uint BuildExplorationFactor</code> - the <code>EF</code> used to create the Vector Set, or the default value of 200 if not specified</li>
<li class=""><code>VectorQuantType QuantType</code> - the quantizier specified at creation time, or the default value of <code>Q8</code> if not specified<!-- -->
<ul>
<li class="">
<blockquote>
<p>[!NOTE]
We have an extension here, <code>XPREQ8</code> which is not from Redis.
This is a quantizier for data sets which have already been 8-bit quantized or are otherwise naturally small byte vectors, and is extremely optimized for reducing reads during queries.
It forbids the <code>REDUCE</code> option and requires 4-byte element ids.</p>
</blockquote>
</li>
<li class="">
<blockquote>
<p>[!IMPORTANT]
Today only <code>XPREQ</code> is actually implemented, eventually DiskANN will provide reasonable versions of all the Redis builtin quantizers.</p>
</blockquote>
</li>
</ul>
</li>
<li class=""><code>Guid ProcessInstanceId</code> - an identifier which is used distinguish the current process from previous instances, this is used after <a href="#recovery" class="">recovery</a> or <a href="#replication" class="">replication</a> to detect if <code>IndexPtr</code> is dangling</li>
</ul>
<p>The index key is in the main store alongside other binary values like strings, hyperloglogs, and so on.  It is distinguished for <code>WRONGTYPE</code> purposes with the <code>VectorSet</code> bit on <code>RecordInfo</code>.</p>
<blockquote>
<p>[!IMPORTANT]
<code>RecordInfo.VectorSet</code> is checked in a few places to correctly produce <code>WRONGTYPE</code> responses, but we need more coverage for all commands.  Probably something akin to how ACLs required per-command tests.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]
A generalization of the <code>VectorSet</code>-bit should be used for all data types, this can happen once we have Store V2.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="elements">Elements<a href="#elements" class="hash-link" aria-label="Direct link to Elements" title="Direct link to Elements" translate="no">​</a></h2>
<p>While the Vector Set API only concerns itself with top-level index keys, ids, vectors, and attributes; DiskANN has different storage needs.  To abstract around these needs a bit, we reserve a number of different &quot;namespaces&quot; for each Vector Set.</p>
<p>These namespaces are simple numbers, starting at the <code>Context</code> value stored in the <code>Index</code> struct - we currently reserve 8 namespaces per Vector Set.  What goes in which namespace is mostly hidden from Garnet, DiskANN indicates namespace (and index) to use with a modified <code>Context</code> passed to relevant callbacks.</p>
<blockquote>
<p>There are two cases where we &quot;know&quot; the namespace involved: attributes (+3) and full vectors (+0) which are used to implement the <code>WITHATTR</code> option and the <code>VEMB</code> command respectively.  These exceptions <em>may</em> go away in the future, but don&#x27;t have to.</p>
</blockquote>
<p>Using namespaces prevents other commands from accessing keys which store element data.</p>
<p>To illustrate, this means that:</p>
<div class="language-text codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">VADD vector-set-key VALUES 1 123 element-key</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">SET element-key string-value</span><br></span></code></pre></div></div>
<p>Can work as expected.  Without namespacing, the <code>SET</code> would overwrite (or otherwise mangle) the element data of the Vector Set.</p>
<h1>Operations</h1>
<p>We implement the <a href="https://redis.io/docs/latest/commands/?group=vector_set" target="_blank" rel="noopener noreferrer" class="">Redis Vector Set API</a>:</p>
<p>Implemented commands:</p>
<ul class="contains-task-list containsTaskList_mC6p">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <!-- -->VADD</li>
<li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->VCARD</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <!-- -->VDIM</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <!-- -->VEMB</li>
<li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->VGETATTR</li>
<li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->VINFO</li>
<li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->VISMEMBER</li>
<li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->VLINKS</li>
<li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->VRANDMEMBER</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <!-- -->VREM</li>
<li class="task-list-item"><input type="checkbox" disabled=""> <!-- -->VSETATTR</li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <!-- -->VSIM</li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="creation-via-vadd">Creation (via <code>VADD</code>)<a href="#creation-via-vadd" class="hash-link" aria-label="Direct link to creation-via-vadd" title="Direct link to creation-via-vadd" translate="no">​</a></h2>
<p><a href="https://redis.io/docs/latest/commands/vadd/" target="_blank" rel="noopener noreferrer" class=""><code>VADD</code></a> implicitly creates a Vector Set when run on an empty key.</p>
<p>DiskANN index creation must be serialized, so this requires holding an exclusive lock (<a href="#locking" class="">more details on locking</a>) that covers just that key.  During the <code>create_index</code> call to DiskANN the read/write/delete callbacks provided may be invoked - accordingly creation is re-entrant and we cannot call <code>create_index</code> directly from any Tsavorite session functions.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="insertion-via-vadd">Insertion (via <code>VADD</code>)<a href="#insertion-via-vadd" class="hash-link" aria-label="Direct link to insertion-via-vadd" title="Direct link to insertion-via-vadd" translate="no">​</a></h2>
<p>Once a Vector Set exists, insertions (which also use <code>VADD</code>) can proceed in parallel.</p>
<p>Every insertion begins with a Tsavorite read, to get the <a href="#indexes" class=""><code>Index</code></a> metadata (for validation) and the pointer to DiskANN&#x27;s index.  As a consequence, most <code>VADD</code> operations despite <em>semantically</em> being writes are, from Tsavorite&#x27;s perspective, reads.  This has implications for replication, <a href="#replication" class="">which is discussed below</a>.</p>
<p>To prevent the index from being deleted mid-insertion, we hold a shared lock while calling DiskANN&#x27;s <code>insert</code> function.  These locks are sharded for performance purposes, <a href="#locking" class="">which is discussed below</a>.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="removal-via-vrem">Removal (via <code>VREM</code>)<a href="#removal-via-vrem" class="hash-link" aria-label="Direct link to removal-via-vrem" title="Direct link to removal-via-vrem" translate="no">​</a></h2>
<p>Removal works much the same as insertion, using shared locks so it can proceed in parallel.  The only meaningful difference is calling DiskANN&#x27;s <code>remove</code> instead of <code>insert</code>.</p>
<blockquote>
<p>[!NOTE]
Removing all elements from a Vector Set is not the same as deleting it.  While it is not possible to create an empty Vector Set with a single command, it is legal for one to exist after a <code>VREM</code>.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="search-via-vsim">Search (via <code>VSIM</code>)<a href="#search-via-vsim" class="hash-link" aria-label="Direct link to search-via-vsim" title="Direct link to search-via-vsim" translate="no">​</a></h2>
<p>Searching is a pure read operation, and so holds shared locks and proceeds in parallel like insertions and removals.</p>
<p>Great care is taken to avoid copying during <code>VSIM</code>.  In particular, values and element ids are passed directly from the receive buffer for all encodings except <code>VALUES</code>.  Callbacks from DiskANN to Garnet likewise take great care to avoid copying, and are <a href="#diskann-integration" class="">detailed below</a>.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="element-data-via-vemb-and-vgetattr">Element Data (via <code>VEMB</code> and <code>VGETATTR</code>)<a href="#element-data-via-vemb-and-vgetattr" class="hash-link" aria-label="Direct link to element-data-via-vemb-and-vgetattr" title="Direct link to element-data-via-vemb-and-vgetattr" translate="no">​</a></h2>
<p>These operations are handled purely on the Garnet side by first reading out the <a href="#indexes" class=""><code>Index</code></a> structure, and then using the context value to look for data in the appropriate namespaces.</p>
<blockquote>
<p>[!NOTE]
Strictly speaking we don&#x27;t need the DiskANN index to access this data, but the current implementation does make sure the index is valid.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="metadata-via-vdim-and-vinfo">Metadata (via <code>VDIM</code> and <code>VINFO</code>)<a href="#metadata-via-vdim-and-vinfo" class="hash-link" aria-label="Direct link to metadata-via-vdim-and-vinfo" title="Direct link to metadata-via-vdim-and-vinfo" translate="no">​</a></h2>
<p>Metadata is handled purely on the Garnet side by reading out the <a href="#indexes" class=""><code>Index</code></a> structure.</p>
<blockquote>
<p>[!NOTE]
<code>VINFO</code> directly exposes Redis implementation details in addition to &quot;normal&quot; data.
Because our implementation is different, we intentionally will not expose all the same information.
To be concrete <code>max-level</code>, <code>vset-uid</code>, and <code>hnsw-max-node-uid</code> are not returned.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]
We <em>may</em> return more details of our own implementation.  What those are need to be documented, and why,
when we implement <code>VINFO</code>.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="deletion-via-del-and-unlink">Deletion (via <code>DEL</code> and <code>UNLINK</code>)<a href="#deletion-via-del-and-unlink" class="hash-link" aria-label="Direct link to deletion-via-del-and-unlink" title="Direct link to deletion-via-del-and-unlink" translate="no">​</a></h2>
<p><code>DEL</code> (and its equivalent <code>UNLINK</code>) is only non-Vector Set command to be routinely expected on a Vector Set key.  It is complicated by not knowing we&#x27;re operating on a Vector Set until we get rather far into deletion.</p>
<p>We cope with this by <em>cancelling</em> the Tsavorite delete operation once we have a <code>RecordInfo</code> with the <code>VectorSet</code>-bit set and a value which is not all zeros, detecting that cancellation in <code>MainStoreOps</code>, and shunting the delete attempt to <code>VectorManager</code>.</p>
<p><code>VectorManager</code> performs the delete in five steps:</p>
<ul>
<li class="">Acquire exclusive locks covering the Vector Set (<a href="#locking" class="">more locking details</a>)</li>
<li class="">Add the key to an <code>InProgressDeletes</code> key (namespace 0, key=0x01)</li>
<li class="">If the index was initialized in the current process (<a href="#recovery" class="">see recovery for more details</a>), call DiskANN&#x27;s <code>drop_index</code> function</li>
<li class="">Perform a write to zero out the index key in Tsavorite</li>
<li class="">Reattempt the Tsavorite delete</li>
<li class="">Cleanup ancillary metadata and schedule element data for cleanup (<a href="#cleanup" class="">more details below</a>)</li>
<li class="">Remove the key from the <code>InProgressDeletes</code> key</li>
</ul>
<p>The <code>InProgressDeletes</code> key is necessary to recover from interrupted deletes.  At process start, <code>VectorManager</code> consults the <code>InProgressDeletes</code> key and completes any deletes that got as far as zero-ing out the index key.</p>
<blockquote>
<p>[!IMPORTANT] Interrupted deletes are expected only during process exits, but if they occur without the process exiting they will leave the Vector Set in a partially deleted state.  We detect that and return a new <code>GarnetStatus.BADSTATE</code> which returns an explanatory error.</p>
<p>We <em>could</em> resume the delete on <code>GarnetStatus.BADSTATE</code>, but like <code>GarnetStatus.WRONGTYPE</code> that needs to be done for <em>all</em> commands not just Vector Set commands.  This work is likewise left for the future.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="flushdb">FlushDB<a href="#flushdb" class="hash-link" aria-label="Direct link to FlushDB" title="Direct link to FlushDB" translate="no">​</a></h2>
<p><code>FLUSHDB</code> (and it&#x27;s relative <code>FLUSHALL</code>) require special handling.</p>
<blockquote>
<p>[!IMPORTANT]
This is not currently implemented.</p>
</blockquote>
<h1>Locking</h1>
<p>Vector Sets workloads require extreme parallelism, and so intricate locking protocols are required for both performance and correctness.</p>
<p>Concretely, there are 3 sorts of locks involved:</p>
<ul>
<li class="">Tsavorite hashbucket locks</li>
<li class="">A <code>ReadOptimizedLock</code> instance</li>
<li class=""><code>VectorManager</code> lock around <code>ContextMetadata</code></li>
</ul>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="tsavorite-locks">Tsavorite Locks<a href="#tsavorite-locks" class="hash-link" aria-label="Direct link to Tsavorite Locks" title="Direct link to Tsavorite Locks" translate="no">​</a></h2>
<p>Whenever we read or write a key/value pair in the main store, we acquire locks in Tsavorite.  Importantly, we cannot start a new Tsavorite operation while still holding these locks - we must copy the index out before each operation so Garnet can use the read/write/delete callbacks.</p>
<blockquote>
<p>[!NOTE]
Based on profiling, Tsavorite shared locks are a significant source of contention.  Even though reads will not block each other we still pay a cache coherency tax.  Accordingly, reducing the number of Tsavorite operations (even reads) can lead to significant performance gains.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]
Some effort was spent early attempting to elide the initial index read in common cases.  This did not pay dividends on smaller clusters, but is worth exploring again on large SKUs.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="readoptimizedlock"><code>ReadOptimizedLock</code><a href="#readoptimizedlock" class="hash-link" aria-label="Direct link to readoptimizedlock" title="Direct link to readoptimizedlock" translate="no">​</a></h2>
<p>As noted above, to prevent <code>DEL</code> from clobbering in use Vector Sets and concurrent <code>VADD</code>s from calling <code>create_index</code> multiple times we have to hold locks based on the Vector Set key.  As every Vector Set operations starts by taking these locks, we have sharded them into separate locks.  To derive many related keys from a single key, we mangle the low bits of a key&#x27;s hash value - this is implemented in the new (but not bound to Vector Sets) type <code>ReadOptimizedLock</code>.</p>
<p>For operations which remain reads, we only acquire a single shared lock (based on the current thread) to prevent destructive operations.</p>
<p>For operations which are always writes (like <code>DEL</code>) we acquire all sharded locks in exclusive mode.</p>
<p>For operations which might be either (like <code>VADD</code>) we first acquire the usual single sharded lock (in shared mode), then promote to an exclusive lock if needed.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="vectormanager-lock-around-contextmetadata"><code>VectorManager</code> Lock Around <code>ContextMetadata</code><a href="#vectormanager-lock-around-contextmetadata" class="hash-link" aria-label="Direct link to vectormanager-lock-around-contextmetadata" title="Direct link to vectormanager-lock-around-contextmetadata" translate="no">​</a></h2>
<p>Whenever we need to allocate a new context or mark an old one for cleanup, we need to modify the cached <code>ContextMetadata</code> and write the new value to Tsavorite.  To simplify this, we take a plain <code>lock</code> around <code>VectorManager</code> while preparing a new <code>ContextMetadata</code>.</p>
<p>The <code>RMW</code> into Tsavorite still proceeds in parallel, outside of the lock, but a version counter in <code>ContextMetadata</code> allows us to keep only the latest version in the store.</p>
<blockquote>
<p>[!NOTE]
Rapid creation or deletion of Vector Sets is expected to perform poorly due to this lock.
This isn&#x27;t a case we&#x27;re very interested in right now, but if that changes this will need to be reworked.</p>
</blockquote>
<h1>Replication</h1>
<p>Replicating Vector Sets is tricky because of the unusual &quot;writes are actually reads&quot;-semantics of most operations.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="on-primaries">On Primaries<a href="#on-primaries" class="hash-link" aria-label="Direct link to On Primaries" title="Direct link to On Primaries" translate="no">​</a></h2>
<p>As noted above, inserts (via <code>VADD</code>) and deletes (via <code>VREM</code>) are reads from Tsavorite&#x27;s perspective.  As a consequence, normal replication (which is triggered via <code>MainSessionFunctions.WriteLog(Delete|RMW|Upsert)</code>) does not happen on those operations.</p>
<p>To fix that, synthetic writes against related keys are made after an insert or remove.  These writes are against the same Vector Set key, but in namespace 0.  See <code>VectorManager.ReplicateVectorSetAdd</code> and <code>VectorManager.ReplicateVectorSetRemove</code> for details.</p>
<blockquote>
<p>[!IMPORTANT]
There is a failure case here where we crash between the insert operation completing and the replication operation completing.</p>
<p>This appears to simply extend a window that already existed between when a Tsavorite operation completed and an entry was written to the AOF.
This needs to confirmed - if it is not the case, handling this failure needs to be figured out.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]
This code assumes a Vector Set under the empty string is illegal.  That does not seem to be true with Redis - so we will need to move these keys elsewhere.  For now, we just forbid the empty key for VADDs.</p>
</blockquote>
<blockquote>
<p>[!NOTE]
These synthetic writes might appear to double write volume, but that is not the case.  Actual inserts and deletes have extreme write amplification (that is, each cause DiskANN to perform many writes against the Main Store), whereas the synthetic writes cause a single (no-op) modification to the Main Store plus an AOF entry.</p>
</blockquote>
<blockquote>
<p>[!NOTE]
The replication key is the same for all operations against the same Vector Set, this could be sharded which may improve performance.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="on-replicas">On Replicas<a href="#on-replicas" class="hash-link" aria-label="Direct link to On Replicas" title="Direct link to On Replicas" translate="no">​</a></h2>
<p>The synthetic writes on primary are intercepted on replicas and redirected to <code>VectorManager.HandleVectorSetAddReplication</code> and <code>VectorManager.HandleVectorSetRemoveReplication</code>, rather than being handled directly by <code>AOFProcessor</code>.</p>
<p>For performance reasons, replicated <code>VADD</code>s are applied across many threads instead of serially.  This introduces a new source of non-determinism, since <code>VADD</code>s will occur in a different order than on the primary, but this is acceptable as Vector Sets are inherently non-deterministic.  While not <em>exactly</em> the same Redis also permits a degree of non-determinism with its <code>CAS</code> option for <code>VADD</code>, so we&#x27;re not diverging an incredible amount here.</p>
<p>While a <code>VADD</code> can proceed in parallel with respect to other <code>VADD</code>s, that is not the case for any other commands.  Accordingly, <code>AofProcessor</code> now calls <code>VectorManager.WaitForVectorOperationsToComplete()</code> before applying any other updates to maintain coherency.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="migration">Migration<a href="#migration" class="hash-link" aria-label="Direct link to Migration" title="Direct link to Migration" translate="no">​</a></h2>
<p>Migrating a Vector Set between two primaries (either as part of a <code>MIGRATE ... KEYS</code> or migration of a whole hash slot) is complicated by storing element data in namespaces.</p>
<p>Namespaces (intentionally) do not participate in hash slots or clustering, and are a node specific concept.  This means that migration must also update the namespaces of elements as they are migrated.</p>
<p>At a high level, migration between the originating primary a destination primary behaves as follows:</p>
<ol>
<li class="">Once target slots transition to <code>MIGRATING</code>...<!-- -->
<ul>
<li class="">An addition to <code>ClusterSession.SingleKeySlotVerify</code> causes all WRITE Vector Set commands to pause once a slot is <code>MIGRATING</code> or <code>IMPORTING</code> - this is necessary because we cannot block based on the key as Vector Sets are composed of many key-value pairs across several namespaces</li>
</ul>
</li>
<li class=""><code>VectorManager</code> on the originating primary enumerates all <em>namespaces</em> and Vector Sets that are covered by those slots</li>
<li class="">The originating primary contacts the destination primary and reserves enough new Vector Set contexts to handled those found in step 2<!-- -->
<ul>
<li class="">These Vector Sets are &quot;in use&quot; but also in a migrating state in <code>ContextMetadata</code></li>
</ul>
</li>
<li class="">During the scan of main store in <code>MigrateOperation</code> any keys found with namespaces found in step 2 are migrated, but their namespace is updated prior to transmission to the appropriate new namespaces reserved in step 3<!-- -->
<ul>
<li class="">Unlike with normal keys, we do not <em>delete</em> the keys in namespaces as we enumerate them</li>
<li class="">Also unlike with normal keys, we synthesize a write on the <em>destination</em> (using a special arg and <code>VADD</code>) so replicas of the destination also get these writes</li>
</ul>
</li>
<li class="">Once all namespace keys are migrated, we migrate the Vector Set index keys, but mutate their values to have the appropriate context reserved in step 3<!-- -->
<ul>
<li class="">As in 4, we synthesize a write on the <em>destination</em> to tell any replicas to also create the index key</li>
</ul>
</li>
<li class="">When the target slots transition back to <code>STABLE</code>, we do a delete of the Vector Set index keys, drop the DiskANN indexes, and schedule the original contexts for cleanup on the originating primary<!-- -->
<ul>
<li class="">Unlike in 4 &amp; 5, we do no synthetic writes here.  The normal replication of <code>DEL</code> will cleanup replicas of the originating primary.</li>
</ul>
</li>
</ol>
<p><code>KEYS</code> migrations differ only in the slot discovery being omitted.  We still have to determine the migrating namespaces, reserve new ones on the destination primary, and schedule cleanup only once migration is completed.  This does mean that, if any of the keys being migrated is a Vector Set, <code>MIGRATE ... KEYS</code> now causes a scan of the main store.</p>
<blockquote>
<p>[!NOTE]
This approach prevents the Vector Set from being visible when it is partially migrated, which has the desirable property of not returning weird results during a migration.</p>
</blockquote>
<blockquote>
<p>[!NOTE]
While we explicitly reserve contexts on primaries, they are implicit on replicas.  This is because a replica should always come up with the same determination of reserved contexts.</p>
<p>To keep that determinism, the synthetic <code>VADD</code>s introduced by migration are not executed in parallel.</p>
</blockquote>
<h1>Cleanup</h1>
<p>Deleting a Vector Set only drops the DiskANN index and removes the top-level keys (ie. the visible key and related hidden keys for replication).  This leaves all element, attribute, neighbor lists, etc. still in the Main Store.</p>
<p>To clean up the remaining data we record the deleted index context value in <code>ContextMetadata</code> and then schedule a full sweep of the Main Store looking for any keys under namespaces related to that context.  When we find those keys we delete them, see <code>VectorManager.RunCleanupTaskAsync()</code> and <code>VectorManager.PostDropCleanupFunctions</code> for details.</p>
<blockquote>
<p>[!NOTE]
There isn&#x27;t really an elegant way to avoid scanning the whole keyspace which can take awhile to free everything up.</p>
<p>If we wanted to explore better options, we&#x27;d need to build something that can drop whole namespaces at once in Tsavorite.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]
Today because we only have ~30 available Vector Set contexts, it is quite likely that deleting a Vector Set and then immediately creating a new one will fail if you&#x27;re near the limit.</p>
<p>This will be fixed once we have arbitrarily long namespaces in Store V2, and have updated <code>ContextMetadata</code> to track those.</p>
</blockquote>
<h1>Recovery</h1>
<p>Vector Sets represent a unique kind of recovery because most operations are mediated through DiskANN, for which we only ever have a pointer to a data structure.  This means that recovery needs to both deal with Vector Sets metadata AND the recreation of the DiskANN side of things.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="vector-set-metadata">Vector Set Metadata<a href="#vector-set-metadata" class="hash-link" aria-label="Direct link to Vector Set Metadata" title="Direct link to Vector Set Metadata" translate="no">​</a></h2>
<p>During startup we read any old <code>ContextMetadata</code> out of the Main Store, cache it, and resume any in progress cleanups.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="vector-sets">Vector Sets<a href="#vector-sets" class="hash-link" aria-label="Direct link to Vector Sets" title="Direct link to Vector Sets" translate="no">​</a></h2>
<p>While reading out <a href="#indexes" class=""><code>Index</code></a> before performing a DiskANN function call, we check the stored <code>ProcessInstanceId</code> against the (randomly generated) one in our <code>VectorManager</code> instance.  If they do not match, we know that the DiskANN <code>IndexPtr</code> is dangling and we need to recreate the index.</p>
<p>To recreate, we acquire exclusive locks (in the same way we would for <code>VADD</code> or <code>DEL</code>) and invoke <code>create_index</code> again.  From DiskANN&#x27;s perspective, there&#x27;s no difference between creating a new empty index and recreating an old one which has existing data.</p>
<p>This means we recreate indexes lazily after recovery.  Consequently the <em>first</em> command (regardless of if it&#x27;s a <code>VADD</code>, a <code>VSIM</code>, or whatever) against an index after recovery will be slower since it needs to do extra work, and will block other commands since it needs exclusive locking.</p>
<blockquote>
<p>[!NOTE]
Today <code>ProcessInstanceId</code> is a <code>GUID</code>, which means we&#x27;re paying for a 16-byte comparison on every command.</p>
<p>This comparison is highly predictable, but we could try and remove the comparison (with caching, as mentioned for <code>Index</code> above).
We could also make it cheaper by using a random <code>ulong</code> instead, but would need to do some math to convince ourselves collisions aren&#x27;t possible in realistic scenarios.</p>
</blockquote>
<h1>DiskANN Integration</h1>
<p>Almost all of how Vector Sets actually function is handled by DiskANN.  Garnet just embeds it, translates between RESP commands and DiskANN functions, and manages storage.</p>
<p>In order for DiskANN to access and store data in Garnet, we provide a set of callbacks.  All callbacks are <code>[UnmanagedCallersOnly]</code> and converted to function pointers before they are passed to Garnet.</p>
<p>All callbacks take a <code>ulong context</code> parameter which identifies the Vector Set involved (the high 61-bits of the context) and the associated namespace (the low 3-bits of the context).  On the Garnet side, the whole <code>context</code> is effectively a namespace, but from DiskANN&#x27;s perspective the top 61-bits are an opaque identifier.</p>
<blockquote>
<p>[!IMPORTANT]
As noted elsewhere, we only have a byte&#x27;s worth of namespaces today - so although <code>context</code> could handle quintillions of Vector Sets, today we&#x27;re limited to just 31.</p>
<p>This restriction will go away with Store V2, but we expect &quot;lower&quot; Vector Sets to out perform &quot;higher&quot; ones due to the need for intermediate data copies with longer namespaces.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="read-callback">Read Callback<a href="#read-callback" class="hash-link" aria-label="Direct link to Read Callback" title="Direct link to Read Callback" translate="no">​</a></h2>
<p>The most complicated of our callbacks, the signature is:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token return-type class-name keyword" style="color:#00009f">void</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">ReadCallbackUnmanaged</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name keyword" style="color:#00009f">ulong</span><span class="token plain"> context</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name keyword" style="color:#00009f">uint</span><span class="token plain"> numKeys</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> keysData</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nuint</span><span class="token plain"> keysLength</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> dataCallback</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> dataCallbackContext</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<p><code>context</code> identifies which Vector Set is being operated on AND the associated namespace, <code>numKeys</code> tells us how many keys have been encoded into <code>keysData</code>, <code>keysData</code> and <code>keysLength</code> define a <code>Span&lt;byte&gt;</code> of length prefixied keys, <code>dataCallback</code> is a <code>delegate* unmanaged[Cdecl, SuppressGCTransition]&lt;int, nint, nint, nuint, void&gt;</code> used to push found keys back into DiskANN, and <code>dataCallbackContext</code> is passed back unaltered to <code>dataCallback</code>.</p>
<p>In the <code>Span&lt;byte&gt;</code> defined by <code>keysData</code> and <code>keysLength</code> the keys are length prefixed with a 4-byte little endian <code>int</code>.  This is necessary to support variable length element ids, but also gives us some scratch space to store a namespace when we convert these to <code>SpanByte</code>s.  This mangling is done as part of the <code>IReadArgBatch</code> implementation we use to read keys from Tsavorite.</p>
<blockquote>
<p>[!NOTE]
Once variable sized namespaces are supported we&#x27;ll have to handle the case where the namespace can&#x27;t fit in 4 bytes.  However, we expect that to be rare (4-bytes would give us ~53,000,000 Vector Sets) and the performance benefits of <em>not</em> copying during querying are very large.</p>
</blockquote>
<p>As we find keys, we invoke <code>dataCallback(index, dataCallbackContext, keyPointer, keyLength)</code>.  If a key is not found, its index is simply skipped.  The benefits of this is that we don&#x27;t copy data out of the Tsavorite log as part of reads, DiskANN is able to do distance calculations and traversal over in-place data.</p>
<blockquote>
<p>[!NOTE]
Each invocation of <code>dataCallback</code> is a managed -&gt; native transition, which can add up very quickly.  We&#x27;ve reduced that as much as possible with function points and <code>SuppressGCTransition</code>, but that comes with risks.</p>
<p>In particular if DiskANN raises an error or blocks in the <code>dataCallback</code> expect very bad things to happen, up to the runtime corrupting itself.  Great care must be taken to keep the DiskANN side of this call cheap and reliable.</p>
</blockquote>
<blockquote>
<p>[!IMPORTANT]
Tsavorite has been extended with a <code>ContextReadWithPrefetch</code> method to accommodate this pattern, which also employs prefetching when we have batches of keys to lookup.</p>
<p>Additionally, some experimentation to figure out good prefetch sizes (and if <a href="https://dl.acm.org/doi/10.14778/2856318.2856321" target="_blank" rel="noopener noreferrer" class="">AMAC</a> is useful) based on hardware is merited.  Right now we&#x27;ve chosen 12 based on testing with some 96-core Intel machines, but that is unlikely to be correct in all interesting circumstances.</p>
</blockquote>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="write-callback">Write Callback<a href="#write-callback" class="hash-link" aria-label="Direct link to Write Callback" title="Direct link to Write Callback" translate="no">​</a></h2>
<p>A simpler callback, the signature is:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token return-type class-name keyword" style="color:#00009f">byte</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">WriteCallbackUnmanaged</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name keyword" style="color:#00009f">ulong</span><span class="token plain"> context</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> keyData</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nuint</span><span class="token plain"> keyLength</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> writeData</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nuint</span><span class="token plain"> writeLength</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<p><code>context</code> identifies which Vector Set is being operated on AND the associated namespace,  <code>keyData</code> and <code>keyLength</code> represent a <code>Span&lt;byte&gt;</code> of the key to write, and <code>writeData</code> and <code>writeLength</code> represent a <code>Span&lt;byte&gt;</code> of the value to write.</p>
<p>DiskANN guarantees an extra 4-bytes BEFORE <code>keyData</code> that we can safely modify.  This is used to avoid copying the key value when we add a namespace to the <code>SpanByte</code> before invoking Tsavorite&#x27;s <code>Upsert</code>.</p>
<p>This callback returns 1 if successful, and 0 otherwise.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="delete-callback">Delete Callback<a href="#delete-callback" class="hash-link" aria-label="Direct link to Delete Callback" title="Direct link to Delete Callback" translate="no">​</a></h2>
<p>Another simple callback, the signature is:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token return-type class-name keyword" style="color:#00009f">byte</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">DeleteCallbackUnmanaged</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name keyword" style="color:#00009f">ulong</span><span class="token plain"> context</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> keyData</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nuint</span><span class="token plain"> keyLength</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<p><code>context</code> identifies which Vector Set is being operated on AND the associated namespace,  and <code>keyData</code> and <code>keyLength</code> represent a <code>Span&lt;byte&gt;</code> of the key to delete.</p>
<p>As with the write callback, DiskANN guarantees an extra 4-bytes BEFORE <code>keyData</code> that we use to store a namespace, and thus avoid copying the key value before invoking Tsavorite&#x27;s <code>Delete</code>.</p>
<p>This callback returns 1 if the key was found and removed, and 0 otherwise.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="read-modify-write-callback">Read Modify Write Callback<a href="#read-modify-write-callback" class="hash-link" aria-label="Direct link to Read Modify Write Callback" title="Direct link to Read Modify Write Callback" translate="no">​</a></h2>
<p>A more complicated callback, the signature is:</p>
<div class="language-csharp codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_QJqH"><pre tabindex="0" class="prism-code language-csharp codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token return-type class-name keyword" style="color:#00009f">byte</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">ReadModifyWriteCallbackUnmanaged</span><span class="token punctuation" style="color:#393A34">(</span><span class="token class-name keyword" style="color:#00009f">ulong</span><span class="token plain"> context</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> keyData</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nuint</span><span class="token plain"> keyLength</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nuint</span><span class="token plain"> writeLength</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> dataCallback</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token class-name">nint</span><span class="token plain"> dataCallbackContext</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre></div></div>
<p><code>context</code> identifies which Vector Set is being operated on AND the associated namespace,  and <code>keyData</code> and <code>keyLength</code> represent a <code>Span&lt;byte&gt;</code> of the key to create, read, or update.</p>
<p><code>writeLength</code> is the desired number of bytes, this is only used used if we are creating a new key-value pair.</p>
<p>As with the write and delete callbacks, DiskANN guarantees an extra 4-bytes BEFORE <code>keyData</code> that we use to store a namespace, and thus avoid copying the key value before invoking Tsavorite&#x27;s <code>RMW</code>.</p>
<p>After we allocate a new key-value pair or find an existing one, <code>dataCallback(nint dataCallbackContext, nint dataPointer, nuint dataLength)</code> is called.  Changes made to data in this callback are persisted.  This needs to be <em>fast</em> to prevent gumming up Tsavorite, as we are under epoch protection.</p>
<p>Newly allocated values are guaranteed to be all zeros.</p>
<p>The callback returns 1 if the key-value pair was found or created, and 0 if some error occurred.</p>
<h2 class="anchor anchorTargetStickyNavbar_Vzrq" id="diskann-functions">DiskANN Functions<a href="#diskann-functions" class="hash-link" aria-label="Direct link to DiskANN Functions" title="Direct link to DiskANN Functions" translate="no">​</a></h2>
<p>Garnet calls into the following DiskANN functions:</p>
<ul class="contains-task-list containsTaskList_mC6p">
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <code>nint create_index(ulong context, uint dimensions, uint reduceDims, VectorQuantType quantType, uint buildExplorationFactor, uint numLinks, nint readCallback, nint writeCallback, nint deleteCallback, nint readModifyWriteCallback)</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <code>void drop_index(ulong context, nint index)</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <code>byte insert(ulong context, nint index, nint id_data, nuint id_len, VectorValueType vector_value_type, nint vector_data, nuint vector_len, nint attribute_data, nuint attribute_len)</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <code>byte remove(ulong context, nint index, nint id_data, nuint id_len)</code></li>
<li class="task-list-item"><input type="checkbox" disabled=""> <code>byte set_attribute(ulong context, nint index, nint id_data, nuint id_len, nint attribute_data, nuint attribute_len)</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <code>int search_vector(ulong context, nint index, VectorValueType vector_value_type, nint vector_data, nuint vector_len, float delta, int search_exploration_factor, nint filter_data, nuint filter_len, nuint max_filtering_effort, nint output_ids, nuint output_ids_len, nint output_distances, nuint output_distances_len, nint continuation)</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <code>int search_element(ulong context, nint index, nint id_data, nuint id_len, float delta, int search_exploration_factor, nint filter_data, nuint filter_len, nuint max_filtering_effort, nint output_ids, nuint output_ids_len, nint output_distances, nuint output_distances_len, nint continuation)</code></li>
<li class="task-list-item"><input type="checkbox" disabled=""> <code>int continue_search(ulong context, nint index, nint continuation, nint output_ids, nuint output_ids_len, nint output_distances, nuint output_distances_len, nint new_continuation)</code></li>
<li class="task-list-item"><input type="checkbox" disabled=""> <code>ulong card(ulong context, nint index)</code></li>
<li class="task-list-item"><input type="checkbox" disabled="" checked=""> <code>byte check_internal_id_valid(ulong context, nint index, nint internal_id, nuint internal_id_len)</code></li>
</ul>
<p>Some non-obvious subtleties:</p>
<ul>
<li class="">The number of results <em>requested</em> from <code>search_vector</code> and <code>search_element</code> is indicated by <code>output_distances_len</code></li>
<li class=""><code>output_distances_len</code> is the number of <em>floats</em> in <code>output_distances</code>, not bytes</li>
<li class="">When inserting, if <code>vector_value_type == FP32</code> then <code>vector_len</code> is the number of <em>floats</em> in <code>vector_data</code>, otherwise it is the number of bytes</li>
<li class=""><code>byte</code> returning functions are effectively returning booleans, <code>0 == false</code> and <code>1 == true</code></li>
<li class=""><code>index</code> is always a pointer created by DiskANN and returned from <code>create_index</code></li>
<li class=""><code>context</code> is always the <code>Context</code> value created by Garnet and stored in <a href="#indexes" class=""><code>Index</code></a> for a Vector Set, this implies it is always a non-0 multiple of 8</li>
<li class=""><code>search_vector</code>, <code>search_element</code>, and <code>continue_search</code> all return the number of ids written into <code>output_ids</code>, and if there are more values to return they set the <code>nint</code> <em>pointed to by</em> <code>continuation</code> or <code>new_continuation</code></li>
</ul>
<blockquote>
<p>[!IMPORTANT]
These p/invoke definitions are all a little rough and should be cleaned up.</p>
<p>They were defined very loosely to ease getting the .NET &lt;-&gt; Rust interface working quickly.</p>
</blockquote></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/microsoft/garnet/tree/main/website/docs/dev/vector-sets.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/garnet/docs/dev/tsavorite/storefunctions"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">StoreFunctions</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/garnet/docs/extensions/module"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Modules</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#global-metadata" class="table-of-contents__link toc-highlight">Global Metadata</a></li><li><a href="#indexes" class="table-of-contents__link toc-highlight">Indexes</a></li><li><a href="#elements" class="table-of-contents__link toc-highlight">Elements</a></li><li><a href="#creation-via-vadd" class="table-of-contents__link toc-highlight">Creation (via <code>VADD</code>)</a></li><li><a href="#insertion-via-vadd" class="table-of-contents__link toc-highlight">Insertion (via <code>VADD</code>)</a></li><li><a href="#removal-via-vrem" class="table-of-contents__link toc-highlight">Removal (via <code>VREM</code>)</a></li><li><a href="#search-via-vsim" class="table-of-contents__link toc-highlight">Search (via <code>VSIM</code>)</a></li><li><a href="#element-data-via-vemb-and-vgetattr" class="table-of-contents__link toc-highlight">Element Data (via <code>VEMB</code> and <code>VGETATTR</code>)</a></li><li><a href="#metadata-via-vdim-and-vinfo" class="table-of-contents__link toc-highlight">Metadata (via <code>VDIM</code> and <code>VINFO</code>)</a></li><li><a href="#deletion-via-del-and-unlink" class="table-of-contents__link toc-highlight">Deletion (via <code>DEL</code> and <code>UNLINK</code>)</a></li><li><a href="#flushdb" class="table-of-contents__link toc-highlight">FlushDB</a></li><li><a href="#tsavorite-locks" class="table-of-contents__link toc-highlight">Tsavorite Locks</a></li><li><a href="#readoptimizedlock" class="table-of-contents__link toc-highlight"><code>ReadOptimizedLock</code></a></li><li><a href="#vectormanager-lock-around-contextmetadata" class="table-of-contents__link toc-highlight"><code>VectorManager</code> Lock Around <code>ContextMetadata</code></a></li><li><a href="#on-primaries" class="table-of-contents__link toc-highlight">On Primaries</a></li><li><a href="#on-replicas" class="table-of-contents__link toc-highlight">On Replicas</a></li><li><a href="#migration" class="table-of-contents__link toc-highlight">Migration</a></li><li><a href="#vector-set-metadata" class="table-of-contents__link toc-highlight">Vector Set Metadata</a></li><li><a href="#vector-sets" class="table-of-contents__link toc-highlight">Vector Sets</a></li><li><a href="#read-callback" class="table-of-contents__link toc-highlight">Read Callback</a></li><li><a href="#write-callback" class="table-of-contents__link toc-highlight">Write Callback</a></li><li><a href="#delete-callback" class="table-of-contents__link toc-highlight">Delete Callback</a></li><li><a href="#read-modify-write-callback" class="table-of-contents__link toc-highlight">Read Modify Write Callback</a></li><li><a href="#diskann-functions" class="table-of-contents__link toc-highlight">DiskANN Functions</a></li></ul></div></div></div></div></main></div></div></div><footer class="theme-layout-footer footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/garnet/docs/getting-started">Getting Started</a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://aka.ms/garnet-discord" target="_blank" rel="noopener noreferrer" class="footer__link-item">Discord<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li><li class="footer__item"><a href="https://twitter.com/msrgarnet" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div><div class="theme-layout-footer-column col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/garnet/blog">Blog</a></li><li class="footer__item"><a href="https://github.com/microsoft/garnet" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright"><p class="text-center">
          <a href="https://go.microsoft.com/fwlink/?LinkId=521839" style="color: white;">Privacy &amp; Cookies</a> |
          <a href="https://go.microsoft.com/fwlink/?LinkID=2259814" style="color: white;">Consumer Health Privacy</a> |
          <a href="https://go.microsoft.com/fwlink/?LinkID=206977" style="color: white;">Terms of Use</a> |
          <a href="https://www.microsoft.com/trademarks" style="color: white;">Trademarks</a> | © 2025
          </p></div></div></div></footer></div>
</body>
</html>