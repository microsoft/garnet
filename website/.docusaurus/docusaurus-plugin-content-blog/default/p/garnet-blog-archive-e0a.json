{"archive":{"blogPosts":[{"id":"etags-when-and-how","metadata":{"permalink":"/garnet/blog/etags-when-and-how","editUrl":"https://github.com/microsoft/garnet/tree/main/website/blog/2025-01-18-etag-when-and-how.md","source":"@site/blog/2025-01-18-etag-when-and-how.md","title":"ETags, When and How","description":"Garnet recently announced native support for ETag-based commands.","date":"2025-01-18T00:00:00.000Z","tags":[{"inline":true,"label":"garnet","permalink":"/garnet/blog/tags/garnet"},{"inline":true,"label":"concurrency","permalink":"/garnet/blog/tags/concurrency"},{"inline":true,"label":"caching","permalink":"/garnet/blog/tags/caching"},{"inline":true,"label":"lock-free","permalink":"/garnet/blog/tags/lock-free"},{"inline":true,"label":"etags","permalink":"/garnet/blog/tags/etags"}],"readingTime":10.71,"hasTruncateMarker":true,"authors":[{"name":"Hamdaan Khalid","title":"Software Engineer, Azure Resource Graph","url":"https://hamdaan-rails-personal.herokuapp.com/about","imageURL":"https://hamdaan-rails-personal.herokuapp.com/assets/me-f1fa367c094eedf1c151b0b0dfbc057c2b047dec4e10f3974167ec3f803d81f0.jpg","key":"hkhalid","page":null},{"name":"Badrish Chandramouli","title":"Partner Research Manager, Microsoft Research","url":"https://badrish.net","imageURL":"https://badrish.net/assets/icons/badrish4.jpg","key":"badrishc","page":null}],"frontMatter":{"slug":"etags-when-and-how","title":"ETags, When and How","authors":["hkhalid","badrishc"],"tags":["garnet","concurrency","caching","lock-free","etags"]},"unlisted":false,"nextItem":{"title":"OSS Announcement","permalink":"/garnet/blog/msr-blog-announcement"}},"content":"**Garnet recently announced native support for ETag-based commands.**  \r\n\r\nNative ETags in a cache-store enable real-world use cases such as maintaining cache consistency, reducing network bandwidth utilization, and avoiding full-blown transactions for several applications.\r\n\r\nGarnet provides native ETag support for raw strings (data added and retrieved using operations such as `GET` and `SET`). It is not available for objects (such as sorted-set, hash, list). This feature is available without requiring any migration, allowing your existing key-value pairs to start leveraging ETags immediately. You can find the ETag API documentation [here](/docs/commands/garnet-specific-commands#native-etag-support).\r\n\r\nThis article explores when and how you can use this new Garnet feature for both your current and future applications.\r\n\r\n<!--truncate-->\r\n\r\n---\r\n\r\n## Why Read This Article?  \r\n\r\nIf you're looking to:  \r\n\r\n1. **Keep your cache consistent with your back-end database**\r\n2. **Reduce network bandwidth utilization for caching.**  \r\n3. **Atomically updating cached records based on client-side update logic.**\r\n\r\nWe'll cover these scenarios one by one below.\r\n\r\n\r\n---\r\n\r\n## Keeping the Cache Consistent with its Back-end Database\r\n\r\nIn a distributed environment it is common to have a cache in front of your main _source of truth_ database. Typically, multiple client applications access the cache and the database at the same time. If every client were to access a different set of keys, the caches can easily be maintained consistenty: a client simply writes to the database and then updates the cache.\r\n\r\nHowever, in cases where a key can be updated by multiple clients, the naive approach of first updating the database and then updating the cache can lead to subtle race conditions. Specifically, whichever client writes to the cache last determines the final state of the cache. This cached state may not ever correspond to the final state of the database for the same key!\r\n\r\nTo make the above scenario clearer, consider a cache-database setup where 2 clients are interacting with the pair. They both follow the same protocol where on writes they first update the database, and then update the cache. We will denote each client by c1 and c2, the request to update the datbase as D, and the request to update the cache as C.\r\n\r\nAll is good for sequences where the last writer to the database is also the last writer to the cache:\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant c1 as Client 1\r\n    participant db as Database\r\n    participant cache as Cache\r\n    participant c2 as Client 2\r\n\r\n    c1->>db: D (older state)\r\n    c2->>db: D (latest state)\r\n    c1->>cache: C (older state)\r\n    c2->>cache: C (latest state)\r\n```\r\n\r\nHowever, if the last writer to the database is NOT the last writer to the case, we introduce a _permanent_ inconsistency between the cache and the database, as the following diagram depicts:\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant c1 as Client 1\r\n    participant db as Database\r\n    participant cache as Cache\r\n    participant c2 as Client 2\r\n\r\n    c1->>db: D (older state)\r\n    c2->>db: D (latest state)\r\n    c2->>cache: C (latest state)\r\n    c1->>cache: C (older state)\r\n```\r\nIn the above sequencing, note that c2 performs the last write to the database. However, c1 performs the last write to the cache. As a result, the cache and the database have gone out of sync.\r\n\r\nFor handling such cases we can rely on the newly introduced ETag feature in Garnet to construct a logical clock around the updates that protect establishing cache consistency (*provided your database also supports ETags or some other form of server-side transactions).\r\n\r\nIn such a scenario the client should use our `SETIFGREATER` API [here](/docs/commands/garnet-specific-commands#setifgreater), when interacting with the cache. `SETIFGREATER` sends a key-value pair along with an etag from the client, and only sets the value if the sent ETag is greater than what is currently set in the cache for that key-value pair.\r\n\r\nEvery client would now follow the following protocol:\r\n- Database stores a pair of (value, etag) on the server\r\n- Use a transaction (or `SETIFGREATER` or `SETIFMATCH` [API](/docs/commands/garnet-specific-commands#setifmatch)) on the database to atomically update `(oldValue, etag)` to `(newValue, etag+1)`, and return the new etag to the client.\r\n- Use the retrieved ETag from our previous call as an argument for SETIFGREATER to update the cache, so that the cache is updated only if the new tag is greater than what is currently stored in the cache.\r\n\r\nIf every client follows the above protocol. We can ensure that only the last/latest database write will be reflected in the cache, leading to eventual consistency. The same sequencing of events as before, but with the clients following our new updated protocol, is shown below:\r\n\r\n```mermaid\r\nsequenceDiagram\r\n    participant c1 as Client 1\r\n    participant db as Database\r\n    participant cache as Cache\r\n    participant c2 as Client 2\r\n\r\n    c1->>db: D (older state with etag 'x')\r\n    c2->>db: D (latest state with etag 'x+1')\r\n    c2->>cache: C (latest state with etag 'x+1')\r\n    c1->>cache: C (older state REJECTED because latest etag on server ('x+1' is higher than sent etag 'x')\r\n```\r\n\r\n\r\n## Reducing Network Bandwidth Utilization for Caching  \r\n\r\nEvery network call incurs a cost: the amount of data transmitted and the distance over which it travels. In performance-sensitive scenarios, it's beneficial to fetch data only if it has changed in the cache, thereby reducing bandwidth usage and network latency.  \r\n\r\n### Scenario: Cache Invalidation \r\nConsider the following setup:  \r\n\r\n#### High-Level Diagram  \r\n```mermaid\r\ngraph TD\r\n    S1[Server 1] -->|reads from cache| C[Cache]\r\n    S2[Server 2] -->|writes to cache, invalidating server 1's read| C \r\n```\r\n\r\n#### Sequence Diagram  \r\n```mermaid\r\nsequenceDiagram\r\n    participant S1 as Server 1\r\n    participant C as Cache\r\n    participant S2 as Server 2\r\n\r\n    S1->>C: initial read from cache for k1\r\n    C-->>S1: Send Data and ETag\r\n    S2->>C: update value for k1 (invalidates k1)\r\n    S1->>C: second read to cache for k1\r\n    C-->>S1: (What is sent back?)\r\n```\r\n\r\nIn the absence of ETags, the entire payload for `k1` is returned on every read, regardless of whether the value associated with `k1` has changed.  \r\n\r\nWhile this might not matter when transferring small payloads (e.g., 100 bytes of data within a high-bandwidth local network), it becomes significant when you have **multiple machines egressing larger payloads (e.g., 1MB each)** on a cloud provider. You pay the cost of egress, bandwidth usage, and experience delays due to the transmission of larger amounts of data.  \r\n\r\nTo address this, Garnet provides the `GETIFNOTMATCH` API [here](/docs/commands/garnet-specific-commands#getifnotmatch).\r\n, allowing you to fetch data only if it has changed since your last retrieval. Server 1 can store the ETag received in the initial payload in application memory and use `GETIFNOTMATCH` to refresh the local copy only if the value has changed.\r\n\r\nThis approach is particularly beneficial in read-heavy systems where data changes infrequently. However, for frequently updated keys, using the regular `GET` API may still be preferable, as updated data will always need to be transmitted.  \r\n\r\nTake a look at the ETag caching sample to see the usage of the `GETIFNOTMATCH` API in action.\r\n\r\n---\r\n\r\n## Avoiding Costly Transactions When Working with Non-Atomic Operations\r\n\r\nCache-stores such as Garnet rely on key-level (or bucket-level) locks on the server to ensure atomic updates by multiple clients to a key-value pair. We often wish to read a remote value, perform some local computations that update the value, and then write the new value back to the server. Due to the cost of the network round-trip and the potential for clients to crash at any time, holding a server-side lock for such a long duration of time is not possible. ETags offer an alternative to transactions when working with such use cases.\r\n\r\n### Scenario: Concurrent updates to the same Value  \r\n\r\nImagine multiple clients concurrently modifying an XML document stored in Garnet.  \r\n\r\nFor example:  \r\n- Client 1 reads the XML, updates Field A, and writes it back.\r\n- Client 2 reads the same XML, updates Field B, and writes it back concurrently.  \r\n\r\nWithout ETags, the following sequence of events might occur:  \r\n1. Client 1 reads value `v0` for key `k1`.  \r\n2. Client 1 modifies Field A, creating a local copy `v1`.  \r\n3. Client 2 reads the same value `v0` before Client 1 writes `v1`.  \r\n4. Client 2 modifies Field B, creating another local copy `v2`.  \r\n5. Either Client 1 or Client 2 writes its version back to the server, potentially overwriting the otherâ€™s changes since `v1` and `v2` both don't have either's changes.\r\n\r\nThis race condition results in lost updates. With ETags, you can use the `SETIFMATCH` API [here](/docs/commands/garnet-specific-commands#setifmatch) to implement a **compare-and-swap** mechanism which guarantees that no updates are lost.\r\n\r\n1. Client 1 reads value `v0` for key `k1`.  \r\n2. Client 1 modifies Field A, creating a local copy `v1`.  \r\n3. Client 2 reads the same value `v0` before Client 1 writes `v1`.  \r\n4. Client 2 modifies Field B, creating another local copy `v2`.  \r\n5. Client 1 does a `SETIFMATCH` to try and install its update, which succeeds.\r\n6. Client 2 does a `SETIFMATCH` to try and install its update, which fails as the server's ETag has now changed.\r\n7. Client 2 retries with the updated value, and eventually succeeds in applying its changes to the value.\r\n\r\n---\r\n\r\nThe following code snippets demonstrate how this can be achieved.\r\n\r\n### Example Code  \r\n\r\n```csharp\r\nstatic async Task Client(string userKey)\r\n{\r\n    Random random = new Random();\r\n    using var redis = await ConnectionMultiplexer.ConnectAsync(GarnetConnectionStr);\r\n    var db = redis.GetDatabase(0);\r\n\r\n    // Initially read the latest ETag\r\n    var res = await EtagAbstractions.GetWithEtag<ContosoUserInfo>(userKey);\r\n    long etag = res.Item1;\r\n    ContosoUserInfo userInfo = res.Item2;\r\n    \r\n    while (true)\r\n    {\r\n        token.ThrowIfCancellationRequested();\r\n        (etag, userInfo) = await ETagAbstractions.PerformLockFreeSafeUpdate<ContosoUserInfo>(\r\n            db, userKey, etag, userInfo, (ContosoUserInfo info) =>\r\n        {\r\n            info.TooManyCats = info.NumberOfCats % 5 == 0;\r\n        });\r\n\r\n        await Task.Delay(TimeSpan.FromSeconds(random.Next(0, 15)), token);\r\n    }\r\n}\r\n```\r\n\r\n#### Supporting Methods  \r\n\r\n```csharp\r\npublic static async Task<(long, T?)> GetWithEtag<T>(IDatabase db, string key)\r\n{\r\n    var executeResult = await db.ExecuteAsync(\"GETWITHETAG\", key);\r\n    if (executeResult.IsNull) return (-1, default(T));\r\n\r\n    RedisResult[] result = (RedisResult[])executeResult!;\r\n    long etag = (long)result[0];\r\n    T item = JsonSerializer.Deserialize<T>((string)result[1]!)!;\r\n    return (etag, item);\r\n}\r\n\r\npublic static async Task<(long, T)> PerformLockFreeSafeUpdate<T>(IDatabase db, string key, long initialEtag, T initialItem, Action<T> updateAction)\r\n{\r\n    // Compare and Swap Updating\r\n    long etag = initialEtag;\r\n    T item = initialItem;\r\n    while (true)\r\n    {\r\n        // perform custom action, since item is updated to it's correct latest state by the server this action is performed exactly once on\r\n        // an item before it is finally updated on the server.\r\n        // NOTE: Based on your application's needs you can modify this method to update a pure function that returns a copy of the data and does not use mutations as side effects.\r\n        updateAction(item);\r\n        var (updatedSuccesful, newEtag, newItem) = await _updateItemIfMatch(db, etag, key, item);\r\n        etag = newEtag;\r\n        if (!updatedSuccesful)\r\n            item = newItem!;\r\n        else\r\n            break;\r\n    }\r\n\r\n    return (etag, item);\r\n}\r\n\r\nprivate static async Task<(bool updated, long etag, T?)> _updateItemIfMatch<T>(IDatabase db, long etag, string key, T value)\r\n{\r\n    string serializedItem = JsonSerializer.Serialize<T>(value);\r\n    RedisResult[] res = (RedisResult[])(await db.ExecuteAsync(\"SETIFMATCH\", key, serializedItem, etag))!;\r\n    // successful update does not return updated value so we can just return what was passed for value. \r\n    if (res[1].IsNull)\r\n        return (true, (long)res[0], value);\r\n\r\n    T deserializedItem = JsonSerializer.Deserialize<T>((string)res[1]!)!;\r\n\r\n    return (false, (long)res[0], deserializedItem);\r\n}\r\n```\r\n\r\nEvery read-(extra logic/modify)-write call starts by first reading the latest etag and value for a key using `GETWITHETAG` [here](/docs/commands/garnet-specific-commands#getwithetag), it then wraps it's update logic in a callback action and then calls the `PerformLockFreeSafeUpdate` method in `ETagAbstractions` to safely apply the update.\r\n\r\nInternally the `PerformLockFreeSafeUpdate` method runs a loop that retrieves the data that performs your update on the object and sends a `SETIFMATCH` request, the server only then updates the value if your ETag indicates that at the time of your decision you had performed your update on the latest copy of the data. If the server sees that between your read and write there were any updates the value, the server sends the latest copy of the data along with the updated etag, your client code then reapplies the changes on the latest copy and resends the request back to the server for the update, this form of update will guarantees that eventually all changes synchronize themselves on the server one after other.\r\n\r\nIn a read-heavy system where contention is not high on the same key this update will be performed in the very first loop itself, and be easier to manage than having a custom transaction. However, in a heavy key contention scenario this could result in multiple attempts to write to the latest copy especially if the logic between your read and write is slow.\r\n\r\n---\r\n\r\nETags are more of a lower level primitives that you can use to build abstractions that let you build logical clocks, and lock free transactions tailored to your needs. If you find yourself in the above commonly found distributed scenarios, you now have another tool in your toolbag to help overcome your scaling needs."},{"id":"msr-blog-announcement","metadata":{"permalink":"/garnet/blog/msr-blog-announcement","editUrl":"https://github.com/microsoft/garnet/tree/main/website/blog/2024-03-18-oss-announcement.md","source":"@site/blog/2024-03-18-oss-announcement.md","title":"OSS Announcement","description":"The Microsoft Research Blog has just published a new post introducing Garnet. Check it out here. Have fun!","date":"2024-03-18T00:00:00.000Z","tags":[{"inline":true,"label":"garnet","permalink":"/garnet/blog/tags/garnet"},{"inline":true,"label":"oss","permalink":"/garnet/blog/tags/oss"},{"inline":true,"label":"announcement","permalink":"/garnet/blog/tags/announcement"},{"inline":true,"label":"msr","permalink":"/garnet/blog/tags/msr"}],"readingTime":0.2,"hasTruncateMarker":false,"authors":[{"name":"Badrish Chandramouli","title":"Partner Research Manager, Microsoft Research","url":"https://badrish.net","imageURL":"https://badrish.net/assets/icons/badrish4.jpg","key":"badrishc","page":null}],"frontMatter":{"slug":"msr-blog-announcement","title":"OSS Announcement","authors":"badrishc","tags":["garnet","oss","announcement","msr"]},"unlisted":false,"prevItem":{"title":"ETags, When and How","permalink":"/garnet/blog/etags-when-and-how"},"nextItem":{"title":"A Brief History of Garnet","permalink":"/garnet/blog/brief-history"}},"content":"The Microsoft Research Blog has just published a new post introducing Garnet. Check it out [here](https://www.microsoft.com/en-us/research/blog/introducing-garnet-an-open-source-next-generation-faster-cache-store-for-accelerating-applications-and-services/). Have fun!"},{"id":"brief-history","metadata":{"permalink":"/garnet/blog/brief-history","editUrl":"https://github.com/microsoft/garnet/tree/main/website/blog/2024-03-17-a-brief-history-of-garnet.md","source":"@site/blog/2024-03-17-a-brief-history-of-garnet.md","title":"A Brief History of Garnet","description":"Hi everyone! I just wanted to start off this blog with a short history of Garnet and how it","date":"2024-03-17T00:00:00.000Z","tags":[{"inline":true,"label":"garnet","permalink":"/garnet/blog/tags/garnet"},{"inline":true,"label":"history","permalink":"/garnet/blog/tags/history"},{"inline":true,"label":"introduction","permalink":"/garnet/blog/tags/introduction"}],"readingTime":2.99,"hasTruncateMarker":false,"authors":[{"name":"Badrish Chandramouli","title":"Partner Research Manager, Microsoft Research","url":"https://badrish.net","imageURL":"https://badrish.net/assets/icons/badrish4.jpg","key":"badrishc","page":null}],"frontMatter":{"slug":"brief-history","title":"A Brief History of Garnet","authors":"badrishc","tags":["garnet","history","introduction"]},"unlisted":false,"prevItem":{"title":"OSS Announcement","permalink":"/garnet/blog/msr-blog-announcement"}},"content":"Hi everyone! I just wanted to start off this blog with a short history of Garnet and how it\r\ncame to exist. At Microsoft Research, we have been working on storage technology\r\nfor a while. In 2016, we started working on a new key-value store design based on epoch protection and\r\na powerful storage API. This project, called [FASTER](https://github.com/microsoft/FASTER), was \r\nopen-sourced in 2018 and gained a lot of traction within Microsoft and in the larger community. FASTER\r\nhas over 6k stars and over half a million NuGet downloads. Over the next several years, we built \r\nfollow-on capabilities such as recoverability (CPR) and serverless support (Netherite), and the \r\nproject was widely adopted.\r\n\r\nAround 2021, we noticed a huge interest in remote cache-stores, particularly using APIs\r\nsuch as the RESP API of Redis. Developers loved the flexibility of both the API and the\r\ndeployment model as a separate process/service. The cost savings compared to accessing \r\ncloud databases directly drove the adoption of caching layers, and these soon\r\ngrew to take up a significant portion of the operating cost of large services. When the\r\npandemic hit and online service usage spiked, there was a strong need for lowering costs\r\nand improving performance (throughput and latency) for such caching layers.\r\n\r\nWe took on the challenge of building a new system, called Garnet, which could provide\r\nextremely high performance end-to-end in a client-server setup while allowing clients\r\nto remain largely unmodified by adopting RESP, the most popular wire protocols out there.\r\nAfter a lot of design effort, we came up with a server threading model that could indeed \r\nmake a huge end-to-end difference, often by orders-of-magnitude, in performance for \r\nbasic get and set operations, with unmodified client code. This gave us the confidence to \r\nbuild out Garnet's feature set towards use in real scenarios.\r\n\r\nThe next question was API coverage. The Redis API is vast, and we were just a small research\r\nteam. Thankfully, our stack was built on .NET, which made tremendous advances in both performance\r\nand richness of libraries. We designed a generic yet powerful way to define and use custom\r\ndata structures, and were able to quickly implement complex datatypes such as Sorted Set, List,\r\nand Hash by reusing data structures in C#. We then built complex structures such as HyperLogLog\r\nand Bitmap as well, and added transactions and extensibility features.\r\n\r\nThe next requirement was scale-out and recovery, for which we designed write-ahead operation logging,\r\nsharding capability, replication, and key migration for dynamic scale-out. By keeping basic compatibility\r\nwith the Redis API, we were able to add these features in a way that existing client code could\r\nbe largely unchanged.\r\n\r\nAfter thousands of unit tests and a couple of years working with first-party teams at Microsoft\r\ndeploying Garnet in production (more on this in future blog posts!), we felt it was time to release \r\nit publicly, just like we did with FASTER five years back. We wanted developers across the planet to \r\nbenefit from this powerful technology and contribute back to the codebase as well. We felt that \r\nthe modern C# codebase would be particularly attractive here, in terms of ease of expansion, \r\nmaintenance, and contribution. Coming from MSR, we also wanted people in academia to conduct research,\r\ncollaborate with us, and expand various aspects of the system.\r\n\r\nSo, explore Garnet, see if you can find use for it in your applications, consider helping us out \r\nwith expanding its capabilities, and as always, let us know what you think!"}]}}